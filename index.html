<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KEYBOARD DOOM â€“ ALL KEYS WORK</title>
<style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;background:#000}
    canvas{display:block;cursor:none}
    #ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;font-family:'Courier New',monospace;color:#fff}
    .hud{position:absolute;font-size:18px;font-weight:bold}
    #hp{top:15px;left:20px}
    #shield{top:40px;left:20px}
    #stage{top:65px;left:20px}
    #timer{top:15px;left:50%;transform:translateX(-50%)}
    #instructions{bottom:20px;left:50%;transform:translateX(-50%);font-size:16px;opacity:.8}
    #menu,#gameover{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all}
    button{margin:15px;padding:18px 36px;font-size:24px;font-family:'Courier New',monospace;background:#222;color:#0f0;border:2px solid #0f0;cursor:pointer;transition:.2s}
    button:hover{background:#0f0;color:#000}
    #gameover h1{font-size:48px;margin-bottom:20px;color:#f00;text-shadow:0 0 10px #f00}
    .damage{position:absolute;font-weight:bold;pointer-events:none;user-select:none;animation:float 1s ease-out forwards}
    @keyframes float{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-60px);opacity:0}}
    .red{color:#f00;text-shadow:0 0 5px #f00}
    .green{color:#0f0;text-shadow:0 0 5px #0f0}
    .blue{color:#00f;text-shadow:0 0 5px #00f}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
    <div id="hp" class="hud">HP: 100/100</div>
    <div id="shield" class="hud">Shield: 0/50</div>
    <div id="stage" class="hud">Stage: -</div>
    <div id="timer" class="hud"></div>
    <div id="instructions" class="hud">DODGE | UNICODE EVENTS | R = RESTART</div>
</div>
<div id="menu">
    <h1 style="font-size:48px;margin-bottom:40px;color:#0f0;text-shadow:0 0 15px #0f0;">KEYBOARD DOOM</h1>
    <button id="precoded">Precoded Order</button>
    <button id="choice">Your Choice</button>
</div>
<div id="gameover" style="display:none;">
    <h1>GAME OVER</h1>
    <p style="margin-bottom:20px;font-size:20px;">Press R to Restart</p>
</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const ui = {
    hp: document.getElementById('hp'),
    shield: document.getElementById('shield'),
    stage: document.getElementById('stage'),
    timer: document.getElementById('timer'),
    menu: document.getElementById('menu'),
    gameover: document.getElementById('gameover')
};
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}
resize();addEventListener('resize',resize);

const state = {
    mode:null, running:false,
    player:{x:0,y:0,r:18},
    realMouse:{x:0,y:0},
    lastMove:0,
    hp:100, maxHp:100,
    shield:0, maxShield:50,
    regenTimer:0,
    keyIdx:0, stageTimer:0, stageDur:8,
    unicodeTimer:0, unicodeInt:0,
    rot:0, tx:0, ty:0, shake:0,
    barrier:{l:60,t:60,r:0,b:0},
    attacks:[], particles:[],
    diff:{}, lastKey:null,
    spawnInterval:null          // <-- cleared on stage change
};

/* ---------- KEYS ---------- */
const keys = [
    'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9',
    '!','@','#','$','%','^','&','*','(',')','_','+',
    '-','=','[',']','{','}','|',';','\'','"',',','.','<','>','?','/',
    ' ','enter','backspace','tab','shift','ctrl','alt','capslock','escape',
    'arrowup','arrowdown','arrowleft','arrowright'
];

/* ---------- ATTACK FACTORY ---------- */
const attacks = {};                     // will be filled automatically
const factory = {
    // ---- a : homing lasers ----
    a(){ const d=getDiff('a'); const n=Math.floor(3+d*1.5);
        const b=[]; for(let i=0;i<n;i++){ const a=i*Math.PI*2/n;
            b.push({x:canvas.width/2+Math.cos(a)*1000,y:canvas.height/2+Math.sin(a)*1000,
                    ang:a+Math.PI,spd:0,tSpd:4+d*2,w:3+d*.8,col:`hsl(${i*90},100%,70%)`,trail:[],hit:0});
        } return {beams:b};
    },
    // ---- b : bouncing bubbles ----
    b(){ const d=getDiff('b'); const n=Math.floor(8+d*3);
        const bub=[]; for(let i=0;i<n;i++){ const a=i*Math.PI*2/n+Math.random()*.5;
            bub.push({x:canvas.width/2+Math.cos(a)*300,y:canvas.height/2+Math.sin(a)*300,
                     vx:Math.cos(a)*(2+d),vy:Math.sin(a)*(2+d),r:15+d*8,col:`hsl(${i*40},100%,70%)`,hit:0});
        } return {bubbles:bub};
    },
    // ---- c : shards + gray wall ----
    c(){ const d=getDiff('c'); const n=Math.floor(6+d*3);
        const s=[]; for(let i=0;i<n;i++){
            let x,y; do{x=state.barrier.l+50+Math.random()*(state.barrier.r-state.barrier.l-100);
                     y=state.barrier.t+50+Math.random()*(state.barrier.b-state.barrier.t-100);
            }while(Math.hypot(x-state.player.x,y-state.player.y)<200);
            s.push({x,y,vx:0,vy:0,tSpd:3+d*1.5,ang:Math.random()*Math.PI*2,spin:(Math.random()-.5)*.25,
                    sz:12+d*7,col:`hsl(${160+i*30},100%,60%)`,hit:0});
        }
        const w={x:canvas.width+200,spd:-(3+d*2),gap:150-d*20,osc:0,hit:0};
        if(w.gap<80)w.gap=80; return {shards:s,wall:w};
    },
    // ---- generic placeholder for every other key ----
    default(k){ return {
        init:()=>{ const d=getDiff(k);
            const objs=[]; for(let i=0;i<Math.floor(4+d*2);i++){
                objs.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,
                           vx:(Math.random()-.5)*(3+d),vy:(Math.random()-.5)*(3+d),
                           r:10+d*5,col:`hsl(${i*60},100%,70%)`,hit:0});
            } return {objs};
        },
        update:(data,dt)=>{ data.objs.forEach(o=>{
            o.x+=o.vx; o.y+=o.vy;
            if(o.x<state.barrier.l+o.r||o.x>state.barrier.r-o.r)o.vx*=-1;
            if(o.y<state.barrier.t+o.r||o.y>state.barrier.b-o.r)o.vy*=-1;
            const dist=Math.hypot(o.x-state.player.x,o.y-state.player.y);
            if(dist<state.player.r+o.r && Date.now()-o.hit>400){
                damage(Math.floor(2+d*.8)); o.hit=Date.now();
                particles(o.x,o.y,o.col,10);
            }
        });},
        draw:(data)=>{ data.objs.forEach(o=>{
            ctx.fillStyle=o.col; ctx.globalAlpha=.7;
            ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill();
            ctx.globalAlpha=1; ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
        });}
    };}
};

/* ---------- BUILD ALL ATTACKS ---------- */
keys.forEach(k=>{
    if(factory[k]) attacks[k]={
        init:factory[k],
        update:(d,dt)=>{ /* custom update will be added later for a,b,c */ },
        draw:(d)=>{ /* custom draw will be added later for a,b,c */ }
    };
    else attacks[k]=factory.default(k);
});

/* ---- custom update / draw for a,b,c ---- */
attacks.a.update = (data,dt)=>{ data.beams.forEach(b=>{
    const dx=state.player.x-b.x, dy=state.player.y-b.y, dist=Math.hypot(dx,dy);
    if(dist>0) b.ang=lerpAngle(b.ang,Math.atan2(dy,dx),.04);
    b.spd=Math.min(b.spd+.3,b.tSpd);
    b.x+=Math.cos(b.ang)*b.spd; b.y+=Math.sin(b.ang)*b.spd;
    b.trail.push({x:b.x,y:b.y}); if(b.trail.length>20)b.trail.shift();
    if(dist<b.r+b.w && Date.now()-b.hit>500){ damage(Math.floor(2+getDiff('a')*.6)); particles(b.x,b.y,b.col,8); b.hit=Date.now(); }
});};
attacks.a.draw = (data)=>{ data.beams.forEach(b=>{
    ctx.strokeStyle=b.col; ctx.lineWidth=b.w; ctx.lineCap='round'; ctx.beginPath();
    b.trail.forEach((p,i)=>{ ctx.globalAlpha=(i/b.trail.length)*.8;
        i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y); }); ctx.globalAlpha=1; ctx.stroke();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(b.x,b.y,b.w*2,0,Math.PI*2); ctx.fill();
});};

attacks.b.update = (data,dt)=>{ data.bubbles.forEach(b=>{
    b.x+=b.vx; b.y+=b.vy;
    if(b.x<state.barrier.l+b.r||b.x>state.barrier.r-b.r)b.vx*=-1.1;
    if(b.y<state.barrier.t+b.r||b.y>state.barrier.b-b.r)b.vy*=-1.1;
    const dist=Math.hypot(b.x-state.player.x,b.y-state.player.y);
    if(dist<state.player.r+b.r && Date.now()-b.hit>400){ damage(Math.floor(3+getDiff('b')*.5)); particles(b.x,b.y,b.col,12); b.hit=Date.now(); }
});};
attacks.b.draw = (data)=>{ data.bubbles.forEach(b=>{
    const p=Math.sin(Date.now()*.01+b.x)*3;
    ctx.fillStyle=b.col; ctx.globalAlpha=.7;
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r+p,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1; ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
});};

attacks.c.update = (data,dt)=>{ data.shards.forEach(s=>{
    const dx=state.player.x-s.x, dy=state.player.y-s.y, dist=Math.hypot(dx,dy);
    if(dist>0) s.ang=lerpAngle(s.ang,Math.atan2(dy,dx),.03);
    const sp=Math.min(dist/80,s.tSpd);
    s.vx=Math.cos(s.ang)*sp; s.vy=Math.sin(s.ang)*sp;
    s.x+=s.vx; s.y+=s.vy; s.ang+=s.spin;
    if(dist<s.r+s.sz/2 && Date.now()-s.hit>450){ damage(Math.floor(2+getDiff('c'))); particles(s.x,s.y,s.col,10); s.hit=Date.now(); }
});
data.wall.osc+=.04; data.wall.x+=data.wall.spd;
if(data.wall.x<-300)data.wall.x=canvas.width+200;
const wx=data.wall.x+60, gy=canvas.height/2-data.wall.gap/2+Math.sin(data.wall.osc)*80;
if(wx>state.player.x-60 && wx<state.player.x+60 && Date.now()-data.wall.hit>600){
    if(state.player.y<gy||state.player.y>gy+data.wall.gap){ damage(Math.floor(4+getDiff('c')*.5)); data.wall.hit=Date.now(); }
}};
attacks.c.draw = (data)=>{ data.shards.forEach(s=>{
    ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.ang);
    ctx.fillStyle=s.col; ctx.beginPath();
    for(let i=0;i<6;i++){ const a=i*Math.PI*2/6, r=s.sz*(i%2?.6:1);
        const x=Math.cos(a)*r, y=Math.sin(a)*r;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);
    } ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.stroke(); ctx.restore();
});
const gy=canvas.height/2-data.wall.gap/2+Math.sin(data.wall.osc)*80;
ctx.fillStyle='#555';
ctx.fillRect(data.wall.x,0,120,gy);
ctx.fillRect(data.wall.x,gy+data.wall.gap,120,canvas.height-(gy+data.wall.gap));
ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(data.wall.x,0,120,canvas.height);
};

/* ---------- HELPERS ---------- */
function lerp(a,b,t){return a+(b-a)*t}
function lerpAngle(a,b,t){let d=b-a; while(d>Math.PI)d-=Math.PI*2; while(d<-Math.PI)d+=Math.PI*2; return a+d*t}
function getDiff(k){ if(!state.diff[k])state.diff[k]=1; return state.diff[k] }
function incDiff(k){
    if(state.lastKey===k){ state.diff[k]=(state.diff[k]||1)*1.25; if(state.diff[k]>6)state.diff[k]=6; }
    else state.diff[k]=1;
    state.lastKey=k;
}
function damage(n){
    if(state.shield>0){ const a=Math.min(n,state.shield); state.shield-=a; popup(state.player.x,state.player.y-30,`S${a}`,'blue'); n-=a; }
    if(n>0){ state.hp-=n; popup(state.player.x,state.player.y-30,`-${n}`,'red'); }
    if(state.hp<=0){state.hp=0; gameOver();}
}
function popup(x,y,t,c){
    const el=document.createElement('div'); el.className=`damage ${c}`;
    el.textContent=t; el.style.left=(x-15)+'px'; el.style.top=(y-20)+'px'; el.style.fontSize='16px';
    document.body.appendChild(el);
    setTimeout(()=>{if(el.parentNode)el.parentNode.removeChild(el)},1000);
}
function particles(x,y,col,cnt){
    for(let i=0;i<cnt;i++) state.particles.push({x,y,
        vx:(Math.random()-.5)*10,vy:(Math.random()-.5)*10-2,life:1,col,size:2+Math.random()*3});
}

/* ---------- GAME FLOW ---------- */
function start(mode){
    state.mode=mode; state.running=true; state.hp=100; state.shield=0;
    state.keyIdx=0; state.stageTimer=0; state.attacks=[]; state.particles=[];
    state.diff={}; state.lastKey=null;
    state.barrier={l:60,t:60,r:canvas.width-60,b:canvas.height-60};
    state.rot=0; state.tx=0; state.ty=0;
    ui.menu.style.display='none'; ui.gameover.style.display='none';
    trigger(keys[0]); state.unicodeInt=4+Math.random()*3; state.unicodeTimer=0;
    if(state.spawnInterval){clearInterval(state.spawnInterval);state.spawnInterval=null;}
}
function trigger(k){
    if(!attacks[k])return;
    incDiff(k); state.stageTimer=0;
    const def=attacks[k];
    state.attacks=[{key:k,data:def.init?def.init():def.init(),timer:0}];
    ui.stage.textContent=`Stage: ${k.toUpperCase()} (${getDiff(k).toFixed(1)}x)`;
}
function next(){
    if(state.mode!=='precoded')return;
    if(state.hp>=state.maxHp){ state.shield=Math.min(state.shield+5,state.maxShield); popup(canvas.width/2,150,'+5 Shield','blue'); }
    else{ state.hp=Math.min(state.hp+10,state.maxHp); popup(canvas.width/2,150,'+10 HP','green'); }
    state.keyIdx=(state.keyIdx+1)%keys.length;
    trigger(keys[state.keyIdx]);
}
function gameOver(){ state.running=false; ui.gameover.style.display='flex'; }
function restart(){ if(state.hp>0 && state.mode==='choice')return; ui.menu.style.display='flex'; ui.gameover.style.display='none'; state.running=false; }

/* ---------- INPUT ---------- */
function norm(e){
    if(e.key===' ')return ' ';
    if(e.key==='Enter')return 'enter';
    if(e.key==='Escape')return 'escape';
    if(e.key==='ArrowUp')return 'arrowup';
    if(e.key==='ArrowDown')return 'arrowdown';
    if(e.key==='ArrowLeft')return 'arrowleft';
    if(e.key==='ArrowRight')return 'arrowright';
    return e.key.toLowerCase();
}
addEventListener('keydown',e=>{
    if(e.key==='Escape'){restart();return;}
    if(e.key.toLowerCase()==='r'){ if(state.hp<=0||state.mode==='precoded')restart(); return; }
    if(state.mode==='choice'&&state.running&&state.hp>0){
        const k=norm(e);
        if(attacks[k])trigger(k);
    }
});
function setMouse(e){
    if(!state.running)return;
    const r=canvas.getBoundingClientRect();
    const x=(e.clientX||e.touches[0].clientX)-r.left;
    const y=(e.clientY||e.touches[0].clientY)-r.top;
    state.realMouse.x=state.player.x=x;
    state.realMouse.y=state.player.y=y;
    state.lastMove=Date.now();
}
canvas.addEventListener('mousemove',setMouse);
canvas.addEventListener('touchmove',e=>{e.preventDefault();setMouse(e)},{passive:false});
canvas.addEventListener('mousedown',setMouse);
canvas.addEventListener('touchstart',e=>{e.preventDefault();setMouse(e)},{passive:false});

document.getElementById('precoded').onclick=()=>start('precoded');
document.getElementById('choice').onclick=()=>start('choice');

/* ---------- UNICODE EVENTS ---------- */
function unicode(){
    const sym=['Right Arrow','Left Arrow','Up Arrow','Down Arrow','Black Square','Diamond'];
    const c=sym[Math.floor(Math.random()*sym.length)];
    ctx.save(); ctx.translate(canvas.width/2,canvas.height/2);
    ctx.font='bold 140px Arial'; ctx.fillStyle='#ff0'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='#ff0'; ctx.shadowBlur=20; ctx.fillText(c,0,0); ctx.restore();
    if(c==='Right Arrow')state.rot+=Math.PI/2;
    else if(c==='Left Arrow')state.rot-=Math.PI/2;
    else if(c==='Up Arrow')state.ty-=80;
    else if(c==='Down Arrow')state.ty+=80;
    else if(c==='Black Square'){
        const s=25; state.barrier.l+=s; state.barrier.t+=s; state.barrier.r-=s; state.barrier.b-=s;
    }
    else if(c==='Diamond')state.shake=.4;
    state.unicodeInt=3+Math.random()*4; state.unicodeTimer=0;
}

/* ---------- MAIN LOOP ---------- */
let last=0;
function loop(t){
    const dt=Math.min((t-last)/1000,.016); last=t;
    if(state.running){
        // cursor return after 3 s
        if(Date.now()-state.lastMove>3000){
            state.player.x=state.realMouse.x;
            state.player.y=state.realMouse.y;
        }
        state.stageTimer+=dt; state.unicodeTimer+=dt; state.regenTimer+=dt;
        if(state.hp<state.maxHp && state.regenTimer>1){ state.hp=Math.min(state.hp+1,state.maxHp); state.regenTimer=0; }
        if(state.mode==='precoded'){
            const rem=state.stageDur-state.stageTimer;
            ui.timer.textContent=`${Math.max(0,rem.toFixed(1))}s`;
            if(state.stageTimer>=state.stageDur)next();
        }else ui.timer.textContent='';
        if(state.unicodeTimer>=state.unicodeInt)unicode();

        state.attacks.forEach(a=>{ a.timer+=dt;
            if(attacks[a.key].update)attacks[a.key].update(a.data,dt);
        });
        state.particles.forEach(p=>{ p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.vy+=200*dt; p.life-=dt*2; });
        state.particles=state.particles.filter(p=>p.life>0);
        if(state.shake>0){ state.tx=(Math.random()-.5)*30; state.ty=(Math.random()-.5)*30; state.shake-=dt; }
        else{ state.tx*=.9; state.ty*=.9; }

        state.player.x=Math.max(state.barrier.l+state.player.r,Math.min(state.barrier.r-state.player.r,state.player.x));
        state.player.y=Math.max(state.barrier.t+state.player.r,Math.min(state.barrier.b-state.player.r,state.player.y));

        ui.hp.textContent=`HP: ${Math.floor(state.hp)}/${state.maxHp}`;
        ui.shield.textContent=`Shield: ${Math.floor(state.shield)}/${state.maxShield}`;
    }

    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(canvas.width/2,canvas.height/2);
    ctx.rotate(state.rot);
    ctx.translate(state.tx-canvas.width/2,state.ty-canvas.height/2);

    ctx.strokeStyle='#0f0'; ctx.lineWidth=4;
    ctx.strokeRect(state.barrier.l,state.barrier.t,state.barrier.r-state.barrier.l,state.barrier.b-state.barrier.t);

    state.attacks.forEach(a=>{ if(attacks[a.key].draw)attacks[a.key].draw(a.data); });

    state.particles.forEach(p=>{ ctx.save(); ctx.globalAlpha=p.life; ctx.fillStyle=p.col;
        ctx.beginPath(); ctx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2); ctx.fill(); ctx.restore();
    });

    // cursor + bars
    const px=state.player.x, py=state.player.y;
    const grad=ctx.createRadialGradient(px,py,0,px,py,state.player.r*2);
    grad.addColorStop(0,'rgba(255,255,255,.6)'); grad.addColorStop(.4,'rgba(100,255,255,.3)'); grad.addColorStop(1,'rgba(0,100,200,0)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(px,py,state.player.r*2,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle='#0ff'; ctx.lineWidth=4; ctx.shadowColor='#0ff'; ctx.shadowBlur=20;
    ctx.beginPath(); ctx.arc(px,py,state.player.r,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur=0;
    ctx.fillStyle='rgba(0,255,255,.8)'; ctx.beginPath(); ctx.arc(px,py,state.player.r*.4,0,Math.PI*2); ctx.fill();

    const bw=50,bh=6,by=py-state.player.r-22;
    ctx.fillStyle='#333'; ctx.fillRect(px-bw/2,by,bw,bh);
    ctx.fillStyle=state.hp>state.maxHp*.5?'#0f0':'#f80';
    ctx.fillRect(px-bw/2,by,bw*(state.hp/state.maxHp),bh);
    ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.strokeRect(px-bw/2,by,bw,bh);

    if(state.shield>0){
        const sy=py+state.player.r+8;
        ctx.fillStyle='#333'; ctx.fillRect(px-bw/2,sy,bw,bh);
        ctx.fillStyle='#00f'; ctx.fillRect(px-bw/2,sy,bw*(state.shield/state.maxShield),bh);
        ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.strokeRect(px-bw/2,sy,bw,bh);
    }

    ctx.restore();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
