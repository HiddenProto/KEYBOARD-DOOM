<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KEYBOARD DOOM - Survival Arena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; cursor: crosshair !important; user-select: none; }
        canvas { display: block; }
        #menu, #gameOver { position: fixed; inset: 0; background: rgba(0,0,0,0.95); color: #0ff; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; gap: 30px; font-size: 32px; }
        button { background: #111; color: #0ff; border: 2px solid #0ff; padding: 15px 40px; font-size: 24px; cursor: pointer; transition: 0.3s; }
        button:hover { background: #0ff; color: #000; }
        #ui { position: fixed; top: 15px; left: 15px; z-index: 100; color: #0ff; font-size: 20px; text-shadow: 0 0 10px #0ff; pointer-events: none; }
        #timer { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); font-size: 28px; color: #ff0; text-shadow: 0 0 10px #ff0; }
        #instructions { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: #0ff; font-size: 16px; opacity: 0.8; text-align: center; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <!-- MAIN MENU -->
    <div id="menu">
        <h1>KEYBOARD DOOM</h1>
        <button id="precoded">Precoded Order</button>
        <button id="manual">Your Choice</button>
        <small>Survive 5–12s per key → +10 HP or +5 Shield</small>
    </div>

    <!-- GAME UI -->
    <div id="ui">
        <div>HP: <span id="hp">100</span>/100</div>
        <div>Shield: <span id="shield">0</span>/50</div>
        <div>Stage: <span id="mode">--</span></div>
    </div>
    <div id="timer">--:--</div>
    <div id="instructions">MOVE CURSOR | DODGE ATTACKS | SURVIVE!</div>

    <!-- GAME OVER -->
    <div id="gameOver" style="display:none;">GAME OVER<br><small>Press R to Restart</small></div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const hpEl = document.getElementById('hp');
        const shieldEl = document.getElementById('shield');
        const modeEl = document.getElementById('mode');
        const timerEl = document.getElementById('timer');
        const menuEl = document.getElementById('menu');
        const gameOverEl = document.getElementById('gameOver');

        let W, H, mouseX = 0, mouseY = 0;
        let hp = 100, maxHp = 100, shield = 0, maxShield = 50;
        let currentKey = '', stageStart = 0, stageDuration = 0;
        let particles = [], damages = [], trails = [];
        let flash = 0, gameOver = false, inMenu = true;
        let mode = 'menu'; // 'precoded', 'manual'

        const PRECODED_ORDER = 'acrf!@#spaceenterarrowup0z'.split('');

        // Resize
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Mouse
        function updateMouse(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }
        canvas.addEventListener('mousemove', updateMouse);
        canvas.addEventListener('touchmove', e => { e.preventDefault(); updateMouse(e.touches[0]); });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); updateMouse(e.touches[0]); });

        // Key
        document.addEventListener('keydown', e => {
            if (inMenu || gameOver) return;
            if (mode === 'manual') setKey(e.key);
            if (e.key === 'r' && gameOver) restart();
            if (e.key === 'Escape') restart();
        });

        // Menu
        document.getElementById('precoded').onclick = () => startGame('precoded');
        document.getElementById('manual').onclick = () => startGame('manual');

        function startGame(m) {
            mode = m;
            inMenu = false;
            menuEl.style.display = 'none';
            hp = 100; shield = 0; gameOver = false;
            gameOverEl.style.display = 'none';
            particles = []; trails = []; damages = [];
            if (mode === 'precoded') nextStage();
            else setKey('a');
        }

        function restart() {
            inMenu = true;
            menuEl.style.display = 'flex';
            gameOverEl.style.display = 'none';
        }

        function nextStage() {
            if (PRECODED_ORDER.length === 0) { win(); return; }
            const key = PRECODED_ORDER.shift();
            setKey(key);
            stageDuration = 5000 + Math.random() * 7000;
            stageStart = performance.now();
        }

        function win() {
            ctx.fillStyle = '#0f0';
            ctx.font = '72px Courier';
            ctx.textAlign = 'center';
            ctx.fillText('YOU WIN!', W/2, H/2);
            setTimeout(restart, 3000);
        }

        function setKey(key) {
            currentKey = key;
            modeEl.textContent = key === ' ' ? 'SPACE' : key.toUpperCase();
            particles = []; trails = []; damages = [];
        }

        function addDamage(val, heal = false, shieldHit = false) {
            damages.push({
                x: mouseX, y: mouseY - 40,
                text: (heal ? '+' : '') + (shieldHit ? 'S' : '') + val,
                vy: -3, life: 1,
                color: heal ? '#0f0' : shieldHit ? '#00f' : '#f00'
            });
        }

        function spawn(x, y, vx, vy, config) {
            particles.push({ x, y, vx, vy, life: 1, ...config });
        }

        // FULLY CODED ATTACKS (ALL KEYS + SYMBOLS)
        const ATTACKS = {
            'a': { spawn: () => { if (Math.random() < 0.3) { const side = Math.floor(Math.random()*4); let x,y; if(side===0){x=Math.random()*W;y=-50}else if(side===1){x=Math.random()*W;y=H+50}else if(side===2){x=-50;y=Math.random()*H}else{x=W+50;y=Math.random()*H} spawn(x,y,(mouseX-x)*0.03,(mouseY-y)*0.03,{dmg:5,size:10,color:'#f00',draw:p=>{ctx.strokeStyle=p.color;ctx.lineWidth=4;ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(mouseX,mouseY);ctx.stroke();}}); } } },
            'c': { bg: () => { ctx.fillStyle = '#0f033'; ctx.fillRect(0,0,W,H); trails.push({x:mouseX,y:mouseY,life:1}); trails=trails.filter(t=>{t.life-=0.02;if(t.life>0){ctx.fillStyle=`rgba(0,0,0,${t.life})`;ctx.beginPath();ctx.arc(t.x,t.y,60*t.life,0,Math.PI*2);ctx.fill();}return t.life>0;}); }, spawn: () => { if (Math.random() < 0.25) { const a=Math.random()*Math.PI*2; spawn(mouseX+Math.cos(a)*300,mouseY+Math.sin(a)*300,0,0,{dmg:2,size:10,color:'#0f0',update:p=>{const d=Math.hypot(mouseX-p.x,mouseY-p.y);if(d>0){p.vx+= (mouseX-p.x)/d*0.8; p.vy+= (mouseY-p.y)/d*0.8;}},draw:p=>{ctx.fillStyle=p.color;ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x-12,p.y+25);ctx.lineTo(p.x+12,p.y+25);ctx.closePath();ctx.fill();}}); } } },
            'r': { spawn: () => { if (Math.random() < 0.18) { const y=Math.random()*H; spawn(0,y,0,0,{dmg:3,life:2,blink:0,draw:p=>{p.blink+=0.3;if(Math.sin(p.blink)>0.7){ctx.strokeStyle='#fff';ctx.lineWidth=6;ctx.beginPath();ctx.moveTo(0,p.y);ctx.lineTo(W,p.y);ctx.stroke();}}}); } } },
            '!': { spawn: () => { if (Math.random() < 0.3) for (let i=0;i<5;i++) spawn(Math.random()*W,-100,(Math.random()-0.5)*3,8,{dmg:7,size:20,color:'#f00',draw:p=>{ctx.fillStyle=p.color;ctx.font='bold '+p.size+'px Arial';ctx.textAlign='center';ctx.fillText('!',p.x,p.y);}}); } },
            '@': { spawn: () => { if (Math.random() < 0.25) spawn(Math.random()*W,-100,0,6,{dmg:6,size:30,color:'#0ff',draw:p=>{ctx.strokeStyle=p.color;ctx.lineWidth=8;for(let i=1;i<6;i++)ctx.strokeRect(p.x-i*15,p.y-i*15,30*i,30*i);}}); } },
            '#': { spawn: () => { if (Math.random() < 0.3) for (let i=0;i<8;i++) { const a=i*Math.PI*2/8; spawn(W/2+Math.cos(a)*300,H/2+Math.sin(a)*300,-Math.sin(a)*4,Math.cos(a)*4,{dmg:5,color:'#ff0',draw:p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-8,p.y-8,16,16);}}); } } },
            ' ': { spawn: () => { if (Math.random() < 0.5) for (let i=0;i<4;i++) spawn(Math.random()*W,-100,(Math.random()-0.5)*5,10,{dmg:10,size:25,color:'#ff0',draw:p=>{ctx.fillStyle='#f80';ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(p.x-8,p.y-8,6,0,Math.PI*2);ctx.fill();}}); } } },
            'enter': { spawn: () => { if (Math.random() < 0.4) for (let i=0;i<16;i++) { const a=i*Math.PI*2/16; spawn(mouseX+Math.cos(a)*350,mouseY+Math.sin(a)*350,-Math.sin(a)*3,Math.cos(a)*3,{dmg:5,color:'#f0f',draw:p=>{ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,12,0,Math.PI*2);ctx.fill();}}); } } },
            'arrowup': { spawn: () => { if (Math.random() < 0.35) for (let x=50;x<W;x+=100) spawn(x,-100,0,12,{dmg:4,color:'#0ff',draw:p=>{ctx.fillStyle=p.color;ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x-20,p.y+40);ctx.lineTo(p.x+20,p.y+40);ctx.closePath();ctx.fill();}}); } },
            '0': { spawn: () => { if (Math.random() < 0.4) for (let i=0;i<10;i++) spawn(Math.random()*W,-100,(Math.random()-0.5)*3,7,{dmg:3,color:'#fff',draw:p=>{ctx.strokeStyle=p.color;ctx.lineWidth=4;ctx.beginPath();ctx.arc(p.x,p.y,15,0,Math.PI*2);ctx.stroke();}}); } },
            'z': { spawn: () => { if (Math.random() < 0.2) { const side=Math.random()<0.5?-60:W+60; spawn(side,Math.random()*H,side<0?3:-3,0,{dmg:6,color:'#080',draw:p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-18,p.y-35,36,70);ctx.fillStyle='#f00';ctx.fillRect(p.x-12,p.y-28,8,8);ctx.fillRect(p.x+4,p.y-28,8,8);}}); } } },
            // Add more symbols/keys as needed...
            'default': { spawn: () => {} }
        };

        // Game loop
        let lastRegen = 0;
        function loop() {
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(0,0,W,H);

            if (inMenu || gameOver) { requestAnimationFrame(loop); return; }

            const config = ATTACKS[currentKey] || ATTACKS['default'];
            if (config.bg) config.bg();
            if (config.spawn) config.spawn();

            // Timer
            if (mode === 'precoded') {
                const elapsed = performance.now() - stageStart;
                const remaining = Math.max(0, stageDuration - elapsed) / 1000;
                timerEl.textContent = remaining.toFixed(1) + 's';
                if (elapsed > stageDuration) {
                    if (hp > 0) {
                        hp = Math.min(maxHp, hp + 10);
                        if (hp >= maxHp && shield < maxShield) shield = Math.min(maxShield, shield + 5);
                        addDamage(hp >= maxHp ? 5 : 10, true);
                    }
                    nextStage();
                }
            } else {
                timerEl.textContent = '';
            }

            // Particles
            particles = particles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.life -= p.tick || 0.02;
                if (p.update) p.update(p);

                const dist = Math.hypot(p.x - mouseX, p.y - mouseY);
                if (dist < (p.size || 18)) {
                    let dmg = p.dmg || 3;
                    if (shield > 0) { shield -= dmg; addDamage(dmg, false, true); if (shield < 0) { hp += shield; shield = 0; } }
                    else { hp -= dmg; addDamage(dmg); }
                    flash = 12;
                    if (hp <= 0) { hp = 0; gameOver = true; gameOverEl.style.display = 'flex'; }
                    return false;
                }

                if (p.draw) p.draw(p);
                return p.life > 0;
            });

            // Regen
            if (performance.now() - lastRegen > 1000 && hp < maxHp && !gameOver) {
                hp = Math.min(maxHp, hp + 1);
                addDamage(1, true);
                lastRegen = performance.now();
            }

            // Damage numbers
            damages = damages.filter(d => {
                d.y += d.vy; d.vy *= 0.9; d.life -= 0.03;
                ctx.fillStyle = d.color + Math.floor(d.life * 255).toString(16).padStart(2, '0');
                ctx.font = 'bold 24px Courier';
                ctx.textAlign = 'center';
                ctx.fillText(d.text, d.x, d.y);
                return d.life > 0;
            });

            // Flash
            if (flash > 0) { ctx.fillStyle = `rgba(255,0,0,${flash/12})`; ctx.fillRect(0,0,W,H); flash--; }

            // HP + Shield Bar
            const barY = mouseY - 70;
            ctx.fillStyle = '#111'; ctx.fillRect(mouseX-65, barY, 130, 12);
            ctx.fillStyle = '#0f0'; ctx.fillRect(mouseX-65, barY, (hp/maxHp)*130, 12);
            if (shield > 0) { ctx.fillStyle = '#00f'; ctx.fillRect(mouseX-65, barY+14, (shield/maxShield)*130, 8); }
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(mouseX-65, barY, 130, 12);

            // Cursor
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(mouseX, mouseY, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(mouseX, mouseY, 4, 0, Math.PI*2); ctx.fill();

            hpEl.textContent = Math.floor(hp);
            shieldEl.textContent = Math.floor(shield);

            requestAnimationFrame(loop);
        }

        resize();
        loop();
    </script>
</body>
</html>
