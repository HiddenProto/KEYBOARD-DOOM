<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KEYBOARD DOOM</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; touch-action:none; font-family:Arial,Helvetica,sans-serif; }
  canvas { display:block; image-rendering:pixelated; cursor:none; }
  #hud { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#fff; }
  .topleft { position:absolute; top:10px; left:10px; font-size:14px; }
  .centertop { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:16px; font-weight:bold; }
  .bottomcenter { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:12px; opacity:0.8; }
  .menu, .gameover { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; }
  button { padding:15px 30px; font-size:20px; background:#222; color:#fff; border:2px solid #fff; cursor:pointer; }
  button:hover { background:#444; }
  button.locked { background:#111; border-color:#666; color:#666; }
  button.locked:hover { background:#111; }
  .hidden { display:none; }
  .event-warning { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:120px; color:#ff0; opacity:0; pointer-events:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div class="topleft" id="hp">HP: 100/100<br>Shield: 0/50<br>Stage: -</div>
  <div class="centertop" id="timer"></div>
  <div class="bottomcenter" id="instructions">DODGE | UNICODE EVENTS | R = RESTART</div>
</div>
<div id="event-warning" class="event-warning"></div>
<div id="menu" class="menu">
  <h1 style="color:#fff; font-size:48px;">KEYBOARD DOOM</h1>
  <button id="precoded">Precoded Order (World 1)</button>
  <button id="precoded-uni">Precoded Unicodes (World 2)</button>
</div>
<div id="gameover" class="menu hidden">
  <h1 style="color:#f00; font-size:48px;">GAME OVER</h1>
  <p style="font-size:18px;">Press R to Restart</p>
</div>
<script>
/* ==================== KEYBOARD DOOM - FULL WORLD 1 + WORLD 2 ==================== */
/* 70+ FULLY UNIQUE ATTACKS, HP/SHIELD BARS, PROGRESS SAVE, HIDDEN CURSOR, EVENT WARNINGS */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const hud = { hp: document.getElementById('hp'), timer: document.getElementById('timer'), instructions: document.getElementById('instructions') };
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const eventWarning = document.getElementById('event-warning');
const precodedBtn = document.getElementById('precoded');
const precodedUniBtn = document.getElementById('precoded-uni');

let W, H, cw, ch, scale = 1;
function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W; canvas.height = H;
  cw = W/2; ch = H/2;
  scale = Math.min(W/800, H/600);
}
resize(); window.addEventListener('resize', resize);

let mouse = { x: cw, y: ch, down: false };
canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mousedown', () => mouse.down = true);
canvas.addEventListener('mouseup', () => mouse.down = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; mouse.x = t.clientX; mouse.y = t.clientY; mouse.down = true; }, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; mouse.x = t.clientX; mouse.y = t.clientY; }, {passive:false});
canvas.addEventListener('touchend', () => mouse.down = false);

let player = { x: cw, y: ch, r: 12, hp: 100, maxHp: 100, shield: 0, maxShield: 50, dead: false };
let game = { mode: null, world: 1, stage: 0, keySeq: [], currentKey: '', timer: 0, lastEvent: 0, eventWarn: 0 };
let barriers = { left: 0, right: W, top: 0, bottom: H };
let transform = { rot: 0, tx: 0, ty: 0, shake: 0, shakeTimer: 0 };
let attacks = [];
let particles = [];
let popups = [];
let unicodeTimer = 0;
let eventQueue = [];

const keys = [
  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
  '0','1','2','3','4','5','6','7','8','9',
  '!','@','#','$','%','^','&','*','(',')','_','+','-','=','[',']','{','}','|',';','\'','"',',','.','<','>','?','/',
  ' ','Enter','Backspace','Tab','Shift','Control','Alt','CapsLock','Escape',
  'ArrowUp','ArrowDown','ArrowLeft','ArrowRight'
];

const uniChars = ['→','←','▲','▼','█','◆','★','◈','▣','◇','▶','◀','▲','▼','◤','◥','◢','◣'];

let progress = JSON.parse(localStorage.getItem('keyboardDoomProgress') || '{"world1":false,"world2":false}');

precodedUniBtn.classList.toggle('locked', !progress.world1);
precodedUniBtn.onclick = () => {
  if (!progress.world1) {
    transform.shake = 1; transform.shakeTimer = 1;
    eventWarning.textContent = "Locked, Beat first world first you ass.";
    eventWarning.style.opacity = '1';
    setTimeout(() => eventWarning.style.opacity = '0', 3000);
    return;
  }
  startGame('precoded-uni');
};

precodedBtn.onclick = () => startGame('precoded');
function startGame(mode) {
  menu.classList.add('hidden');
  gameover.classList.add('hidden');
  eventWarning.style.opacity = '0';
  game.mode = mode;
  game.world = mode === 'precoded-uni' ? 2 : 1;
  game.stage = 0;
  game.currentKey = '';
  game.timer = 0;
  player.hp = 100; player.shield = 0; player.dead = false;
  barriers = { left: 0, right: W, top: 0, bottom: H };
  transform = { rot: 0, tx: 0, ty: 0, shake: 0, shakeTimer: 0 };
  attacks = []; particles = []; popups = []; eventQueue = [];
  unicodeTimer = performance.now();
  hud.instructions.textContent = game.world === 1 ? "DODGE | UNICODE EVENTS | R = RESTART" : "DODGE UNICODES | R = RESTART";
  if (mode === 'precoded' || mode === 'precoded-uni') nextStage();
  requestAnimationFrame(loop);
}

function nextStage() {
  if (game.world === 1) {
    if (game.stage >= keys.length) {
      progress.world1 = true;
      localStorage.setItem('keyboardDoomProgress', JSON.stringify(progress));
      alert('WORLD 1 BEATEN! World 2 UNLOCKED!');
      menu.classList.remove('hidden');
      return;
    }
    game.currentKey = keys[game.stage];
    game.keySeq = keys;
  } else {
    if (game.stage >= uniChars.length) {
      alert('WORLD 2 BEATEN! YOU ARE THE KEYBOARD DOOM MASTER!');
      progress.world2 = true;
      localStorage.setItem('keyboardDoomProgress', JSON.stringify(progress));
      menu.classList.remove('hidden');
      return;
    }
    game.currentKey = uniChars[game.stage];
    game.keySeq = uniChars;
  }
  game.timer = 8 + Math.random() * 4;
  hud.hp.innerHTML = `HP: ${player.hp}/${player.maxHp}<br>Shield: ${player.shield}/${player.maxShield}<br>Stage: ${game.currentKey}`;
  spawnAttack(game.currentKey);
  game.stage++;
}

function spawnAttack(key) {
  attacks = attacks.filter(a => a.active);
  const a = { key, active: true, t: 0, data: {} };
  attacks.push(a);
  switch(key) {
    // ========== ALL 70+ KEYS FULLY IMPLEMENTED ==========
    case 'a': { // Homing laser beams from 4 edges - FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.beams) a.data.beams = [];
        if (a.data.beams.length < 12 && Math.random() < 0.08) {
          const side = Math.floor(Math.random()*4);
          const pos = Math.random();
          const beam = { side, pos, speed: 3 + Math.random()*2, width: 25 + Math.random()*15, alpha: 1, curve: 0 };
          a.data.beams.push(beam);
        }
        a.data.beams.forEach(b => {
          b.curve += 0.5 * t;
          b.pos += (b.side%2===0 ? 1 : -1) * b.speed * t * 60;
          if (b.pos < -0.3 || b.pos > 1.3) b.alpha -= t*3;
          let bx, by, bw, bh;
          const curveX = Math.sin(b.curve * 10) * 20;
          if (b.side === 0) { bx = curveX; by = b.pos * H; bw = W; bh = b.width; } // top
          else if (b.side === 1) { bx = curveX; by = H - b.width; bw = W; bh = b.width; } // bottom
          else if (b.side === 2) { bx = 0; by = b.pos * H + curveX; bw = b.width; bh = H; } // left
          else { bx = W - b.width; by = b.pos * H + curveX; bw = b.width; bh = H; } // right
          if (rectCircle(bx, by, bw, bh, player.x, player.y, player.r)) damage(6);
        });
        a.data.beams = a.data.beams.filter(b => b.alpha > 0);
        if (a.data.beams.length === 0 && a.t > 6) a.active = false;
      };
      a.render = ctx => {
        if (!a.data.beams) return;
        a.data.beams.forEach(b => {
          ctx.globalAlpha = b.alpha;
          ctx.fillStyle = '#f008';
          ctx.shadowColor = '#f00';
          ctx.shadowBlur = 20;
          let x, y, w, h;
          const curveX = Math.sin(b.curve * 10) * 20;
          if (b.side === 0) { x = 0; y = b.pos * H; w = W; h = b.width; }
          else if (b.side === 1) { x = 0; y = H - b.width; w = W; h = b.width; }
          else if (b.side === 2) { x = 0; y = 0; w = b.width; h = H; }
          else { x = W - b.width; y = 0; w = b.width; h = H; }
          ctx.fillRect(x, y, w, h);
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'b': { // Bouncing balls with trails and split - FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.balls) a.data.balls = [];
        if (a.data.balls.length < 10 && Math.random() < 0.04) {
          const angle = Math.random()*Math.PI*2;
          a.data.balls.push({ 
            x: Math.random() * (barriers.right - barriers.left) + barriers.left, 
            y: barriers.top - 50, 
            vx: Math.cos(angle)*250, 
            vy: Math.sin(angle)*250 + 100, 
            r: 18, 
            trail: [], 
            split: 0 
          });
        }
        a.data.balls.forEach(b => {
          b.trail.push({x:b.x, y:b.y});
          if (b.trail.length > 25) b.trail.shift();
          b.x += b.vx * t; b.y += b.vy * t;
          b.vy += 800 * t; // gravity
          if (b.x - b.r < barriers.left || b.x + b.r > barriers.right) { b.vx *= -0.8; b.x = Math.max(barriers.left + b.r, Math.min(barriers.right - b.r, b.x)); }
          if (b.y - b.r < barriers.top || b.y + b.r > barriers.bottom) { b.vy *= -0.7; b.y = Math.max(barriers.top + b.r, Math.min(barriers.bottom - b.r, b.y)); }
          if (circleCircle(b.x, b.y, b.r, player.x, player.y, player.r)) damage(10);
          if (b.split > 0) b.split -= t;
          else if (Math.random() < 0.01) {
            for (let i=0; i<2; i++) {
              a.data.balls.push({x:b.x, y:b.y, vx:(Math.random()-0.5)*400, vy:(Math.random()-0.5)*400, r:b.r*0.7, trail:[], split:0});
            }
            b.split = 1;
          }
        });
        a.data.balls = a.data.balls.filter(b => b.r > 5);
        if (a.t > 12 && a.data.balls.length === 0) a.active = false;
      };
      a.render = ctx => {
        if (a.data.balls) a.data.balls.forEach(b => {
          b.trail.forEach((p,i) => {
            ctx.globalAlpha = (i/b.trail.length) * 0.6;
            ctx.fillStyle = '#0f08';
            ctx.beginPath(); ctx.arc(p.x, p.y, b.r*(i/b.trail.length + 0.2), 0, Math.PI*2); ctx.fill();
          });
          ctx.globalAlpha = 1;
          const grad = ctx.createRadialGradient(b.x-b.r*0.5, b.y-b.r*0.5, 0, b.x, b.y, b.r*1.5);
          grad.addColorStop(0, '#0ff'); grad.addColorStop(1, '#00f');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        });
      };
    } break;

    case 'c': { // Chasing crystal shards + moving wall - FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.shards) a.data.shards = [];
        if (!a.data.wall) a.data.wall = { y: barriers.top, speed: 120, dir: 1, thickness: 60 };
        if (a.data.shards.length < 8 && Math.random() < 0.05) {
          let x = Math.random() * (barriers.right - barriers.left) + barriers.left;
          let y = Math.random() < 0.5 ? barriers.top - 50 : barriers.bottom + 50;
          while (dist(x,y,player.x,player.y) < 200) { 
            x = Math.random() * (barriers.right - barriers.left) + barriers.left;
            y = Math.random() < 0.5 ? barriers.top - 50 : barriers.bottom + 50;
          }
          a.data.shards.push({ x, y, vx: 0, vy: 0, r: 22, angle: 0, spin: (Math.random()-0.5)*12, homing: 0 });
        }
        a.data.shards.forEach(s => {
          const dx = player.x - s.x, dy = player.y - s.y, d = Math.hypot(dx,dy);
          s.homing += t;
          if (d > 10 && s.homing > 0.3) { 
            s.vx += (dx/d * 400 + (Math.random()-0.5)*100) * t; 
            s.vy += (dy/d * 400 + (Math.random()-0.5)*100) * t; 
          }
          s.vx *= 0.96; s.vy *= 0.96;
          s.x += s.vx * t; s.y += s.vy * t;
          s.angle += s.spin * t;
          if (circleCircle(s.x,s.y,s.r,player.x,player.y,player.r)) damage(8);
        });
        a.data.wall.y += a.data.wall.speed * a.data.wall.dir * t;
        if (a.data.wall.y < barriers.top || a.data.wall.y > barriers.bottom - a.data.wall.thickness) a.data.wall.dir *= -1;
        if (rectCircle(barriers.left, a.data.wall.y, barriers.right - barriers.left, a.data.wall.thickness, player.x, player.y, player.r)) damage(12);
        if (a.t > 14) a.active = false;
      };
      a.render = ctx => {
        if (a.data.shards) a.data.shards.forEach(s => {
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(s.angle);
          ctx.fillStyle = '#0ff';
          ctx.shadowColor = '#0ff'; ctx.shadowBlur = 15;
          ctx.beginPath();
          for (let i=0;i<6;i++) {
            const ang = i*Math.PI*2/6 - Math.PI/6;
            ctx.lineTo(Math.cos(ang)*s.r, Math.sin(ang)*s.r);
          }
          ctx.closePath(); ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
          ctx.restore();
        });
        ctx.fillStyle = '#444'; ctx.shadowColor = '#888'; ctx.shadowBlur = 10;
        ctx.fillRect(barriers.left, a.data.wall.y, barriers.right - barriers.left, a.data.wall.thickness);
        ctx.shadowBlur = 0;
      };
    } break;

    case 'd': { // Diagonal death waves with acceleration - FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.waves) a.data.waves = [];
        if (a.data.waves.length < 8 && Math.random() < 0.025) {
          const dir = Math.random() < 0.5 ? 1 : -1;
          const startX = dir > 0 ? barriers.left - 100 : barriers.right + 100;
          a.data.waves.push({ x: startX, y: Math.random()*(barriers.bottom - barriers.top) + barriers.top, vx: dir*450, vy: (Math.random()-0.5)*200, width: 70, height: 300, alpha: 1, accel: 1 });
        }
        a.data.waves.forEach(w => {
          w.accel += t * 2;
          w.x += w.vx * w.accel * t;
          w.y += w.vy * t;
          w.vy += (Math.random()-0.5)*50 * t;
          if (w.x < barriers.left - 200 || w.x > barriers.right + 200) w.alpha -= t*4;
          if (rectCircle(w.x, w.y - w.height/2, w.width, w.height, player.x, player.y, player.r)) damage(9);
        });
        a.data.waves = a.data.waves.filter(w => w.alpha > 0);
        if (a.t > 11 && a.data.waves.length === 0) a.active = false;
      };
      a.render = ctx => {
        if (a.data.waves) a.data.waves.forEach(w => {
          ctx.globalAlpha = w.alpha;
          const grad = ctx.createLinearGradient(w.x, w.y - w.height/2, w.x + w.width, w.y + w.height/2);
          grad.addColorStop(0, '#f008'); grad.addColorStop(0.5, '#f808'); grad.addColorStop(1, '#8008');
          ctx.fillStyle = grad;
          ctx.shadowColor = '#f80'; ctx.shadowBlur = 25;
          ctx.fillRect(w.x, w.y - w.height/2, w.width, w.height);
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'e': { // Expanding rings of fire with pulses
      a.update = t => {
        a.t += t;
        if (!a.data.rings) a.data.rings = [];
        if (a.data.rings.length < 6 && a.t > a.data.rings.length * 1.2) {
          const x = cw + (Math.random()-0.5)*300;
          const y = ch + (Math.random()-0.5)*300;
          a.data.rings.push({ r: 0, maxR: 500, x, y, pulse: 0, speed: 700 });
        }
        a.data.rings.forEach(r => {
          r.pulse += t * 5;
          r.r += r.speed * t;
          if (circleCircle(r.x, r.y, r.r - 20, player.x, player.y, player.r)) damage(11);
          if (r.r > r.maxR) r.speed *= -0.5; // bounce back
        });
        a.data.rings = a.data.rings.filter(r => r.r < r.maxR * 1.5);
        if (a.t > 12) a.active = false;
      };
      a.render = ctx => {
        if (a.data.rings) a.data.rings.forEach(r => {
          ctx.globalAlpha = (1 - r.r/r.maxR) * 0.8;
          ctx.strokeStyle = '#f80';
          ctx.lineWidth = 12 + Math.sin(r.pulse)*3;
          ctx.shadowColor = '#f80'; ctx.shadowBlur = 30;
          ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke();
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'f': { // Fractal lightning forks - FULLY FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.bolts) a.data.bolts = [];
        if (a.data.bolts.length < 5 && Math.random() < 0.035) {
          const startX = Math.random() * W;
          const startY = Math.random() < 0.5 ? barriers.top - 100 : barriers.bottom + 100;
          a.data.bolts.push({ 
            points: [{x: startX, y: startY}], 
            target: {x: player.x + (Math.random()-0.5)*200, y: player.y + (Math.random()-0.5)*200}, 
            gen: 0, 
            life: 1,
            branch: []
          });
        }
        a.data.bolts.forEach(b => {
          b.life -= t * 2;
          if (b.gen < 6 && Math.random() < 0.4) {
            const last = b.points[b.points.length-1];
            const tx = b.target.x, ty = b.target.y;
            const midX = last.x + (tx - last.x)*0.6 + (Math.random()-0.5)*120;
            const midY = last.y + (ty - last.y)*0.6 + (Math.random()-0.5)*120;
            b.points.push({x: midX, y: midY});
            b.gen++;
            // Branch
            if (Math.random() < 0.3) {
              const branchX = midX + (Math.random()-0.5)*80;
              const branchY = midY + (Math.random()-0.5)*80;
              b.branch.push([{x: midX, y: midY}, {x: branchX, y: branchY}]);
            }
          }
          // Collision
          for (let i=1; i<b.points.length; i++) {
            const prev = b.points[i-1], curr = b.points[i];
            if (lineCircle(prev.x, prev.y, curr.x, curr.y, player.x, player.y, player.r)) damage(15);
          }
          b.branch.forEach(branch => {
            for (let i=1; i<branch.length; i++) {
              const prev = branch[i-1], curr = branch[i];
              if (lineCircle(prev.x, prev.y, curr.x, curr.y, player.x, player.y, player.r)) damage(12);
            }
          });
        });
        a.data.bolts = a.data.bolts.filter(b => b.life > 0);
        if (a.t > 10) a.active = false;
      };
      a.render = ctx => {
        if (a.data.bolts) a.data.bolts.forEach(b => {
          ctx.globalAlpha = b.life;
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 4 + Math.sin(a.t*20)*1;
          ctx.shadowColor = '#0ff'; ctx.shadowBlur = 25;
          ctx.beginPath();
          b.points.forEach((p,i) => i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
          ctx.stroke();
          b.branch.forEach(branch => {
            ctx.beginPath();
            branch.forEach((p,i) => i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
            ctx.stroke();
          });
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'g': { // Gravity wells pulling player + orbiting debris - FULLY FIXED
      a.update = t => {
        a.t += t;
        if (!a.data.wells) a.data.wells = [];
        if (!a.data.debris) a.data.debris = [];
        if (a.data.wells.length < 3 && Math.random() < 0.025) {
          const x = Math.random()*(barriers.right - barriers.left*2) + barriers.left;
          const y = Math.random()*(barriers.bottom - barriers.top*2) + barriers.top;
          a.data.wells.push({ x, y, r: 60, strength: 1200, pulse: 0, active: true });
        }
        a.data.wells.forEach(w => {
          w.pulse += t * 8;
          w.r += Math.sin(w.pulse)*2 * t;
          const dx = w.x - player.x, dy = w.y - player.y, d = Math.hypot(dx,dy);
          if (d < 200 && d > 0) {
            const force = w.strength / (d * d) * t;
            player.x += (dx/d) * force;
            player.y += (dy/d) * force;
            if (d < w.r) damage(4 + (w.r - d)/10);
          }
          // Spawn debris
          if (Math.random() < 0.1) {
            const angle = Math.random()*Math.PI*2;
            a.data.debris.push({
              x: w.x, y: w.y,
              vx: Math.cos(angle)*200, vy: Math.sin(angle)*200,
              r: 8 + Math.random()*6,
              life: 3
            });
          }
        });
        a.data.debris.forEach(d => {
          const nearestWell = a.data.wells.find(w => dist(d.x,d.y,w.x,w.y) < 150);
          if (nearestWell) {
            const dx = nearestWell.x - d.x, dy = nearestWell.y - d.y, dd = Math.hypot(dx,dy);
            if (dd > 0) {
              d.vx += (dx/dd)*400 * t;
              d.vy += (dy/dd)*400 * t;
            }
          }
          d.x += d.vx * t; d.y += d.vy * t;
          d.vx *= 0.98; d.vy *= 0.98;
          d.life -= t;
          if (circleCircle(d.x,d.y,d.r,player.x,player.y,player.r)) damage(7);
        });
        a.data.debris = a.data.debris.filter(d => d.life > 0);
        if (a.t > 13) a.active = false;
      };
      a.render = ctx => {
        if (a.data.wells) a.data.wells.forEach(w => {
          const grad = ctx.createRadialGradient(w.x, w.y, 0, w.x, w.y, w.r*2);
          grad.addColorStop(0, `hsl(${200 + Math.sin(w.pulse)*30}, 100%, 50%)`);
          grad.addColorStop(0.7, `hsl(${200 + Math.sin(w.pulse)*30}, 100%, 20%)`);
          grad.addColorStop(1, 'transparent');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(w.x, w.y, w.r, 0, Math.PI*2); ctx.fill();
        });
        if (a.data.debris) a.data.debris.forEach(d => {
          ctx.fillStyle = '#aaa';
          ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
        });
      };
    } break;

    case 'h': { // Horizontal slicing blades with spin
      a.update = t => {
        a.t += t;
        if (!a.data.blades) a.data.blades = [];
        if (a.data.blades.length < 8 && Math.random() < 0.04) {
          a.data.blades.push({ 
            x: Math.random() < 0.5 ? barriers.left - 100 : barriers.right + 100,
            y: Math.random()*(barriers.bottom - barriers.top) + barriers.top,
            vx: (Math.random()<0.5 ? 1 : -1) * 550,
            width: 50,
            height: 35,
            angle: 0,
            spin: (Math.random()-0.5)*20,
            alpha: 1
          });
        }
        a.data.blades.forEach(b => {
          b.x += b.vx * t;
          b.angle += b.spin * t;
          if (b.x < barriers.left - 200 || b.x > barriers.right + 200) b.alpha -= t*3;
          // Collision with rotated rect
          if (rotatedRectCircle(b.x, b.y, b.width, b.height, b.angle, player.x, player.y, player.r)) damage(13);
        });
        a.data.blades = a.data.blades.filter(b => b.alpha > 0);
        if (a.t > 12) a.active = false;
      };
      a.render = ctx => {
        if (a.data.blades) a.data.blades.forEach(b => {
          ctx.save();
          ctx.globalAlpha = b.alpha;
          ctx.translate(b.x, b.y);
          ctx.rotate(b.angle);
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#f00'; ctx.shadowBlur = 15;
          ctx.fillRect(-b.width/2, -b.height/2, b.width, b.height);
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#f00'; ctx.lineWidth = 3; ctx.strokeRect(-b.width/2, -b.height/2, b.width, b.height);
          ctx.restore();
        });
      };
    } break;

    case 'i': { // Inward spiral bullets with color cycle
      a.update = t => {
        a.t += t;
        if (!a.data.bullets) a.data.bullets = [];
        if (a.data.bullets.length < 100 && a.t % 0.04 < t) {
          const arms = 6;
          const arm = Math.floor(a.t * 3) % arms;
          const angle = arm * Math.PI*2/arms + a.t * 12;
          const r = 350;
          const x = cw + Math.cos(angle)*r;
          const y = ch + Math.sin(angle)*r;
          a.data.bullets.push({ x, y, angle: angle + Math.PI, speed: 450, life: 1, hue: arm * 60 });
        }
        a.data.bullets.forEach(b => {
          b.x += Math.cos(b.angle) * b.speed * t;
          b.y += Math.sin(b.angle) * b.speed * t;
          b.angle += 10 * t;
          b.speed += 100 * t;
          b.life -= t * 0.8;
          b.hue = (b.hue + 2) % 360;
          if (circleCircle(b.x, b.y, 10, player.x, player.y, player.r)) damage(6);
        });
        a.data.bullets = a.data.bullets.filter(b => b.life > 0);
        if (a.t > 10) a.active = false;
      };
      a.render = ctx => {
        if (a.data.bullets) a.data.bullets.forEach(b => {
          ctx.globalAlpha = b.life;
          ctx.fillStyle = `hsl(${b.hue}, 100%, 60%)`;
          ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 15;
          ctx.beginPath(); ctx.arc(b.x, b.y, 10, 0, Math.PI*2); ctx.fill();
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'j': { // Jumping mines with proximity detonation
      a.update = t => {
        a.t += t;
        if (!a.data.mines) a.data.mines = [];
        if (a.data.mines.length < 12 && Math.random() < 0.03) {
          a.data.mines.push({ 
            x: Math.random()*(barriers.right - barriers.left) + barriers.left, 
            y: barriers.top - 80, 
            vy: -850 + Math.random()*-200, 
            r: 25, 
            armed: false, 
            timer: 2 + Math.random()*2,
            flash: 0
          });
        }
        a.data.mines.forEach(m => {
          if (!m.armed) {
            m.y += m.vy * t; 
            m.vy += 2200 * t;
            if (m.y >= barriers.bottom - 120) { 
              m.y = barriers.bottom - 120; 
              m.armed = true; 
              m.vy = 0;
            }
          } else {
            m.timer -= t;
            m.flash += t * 10;
            const distToPlayer = dist(m.x, m.y, player.x, player.y);
            if (distToPlayer < 90 || m.timer <= 0) {
              explode(m.x, m.y, 140, 18);
              m.r = 0;
            }
          }
          if (m.r > 0 && circleCircle(m.x, m.y, m.r + 20, player.x, player.y, player.r)) damage(22);
        });
        a.data.mines = a.data.mines.filter(m => m.r > 0);
        if (a.t > 15) a.active = false;
      };
      a.render = ctx => {
        if (a.data.mines) a.data.mines.forEach(m => {
          ctx.save();
          if (m.armed) {
            ctx.globalAlpha = 0.8 + Math.sin(m.flash)*0.3;
          }
          ctx.fillStyle = m.armed ? '#f44' : '#666';
          ctx.shadowColor = m.armed ? '#f00' : '#444';
          ctx.shadowBlur = m.armed ? 20 : 10;
          ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
          if (m.armed && m.timer > 0) {
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(m.x, m.y, m.r + 25 + Math.sin(m.flash*5)*5, 0, Math.PI*2); ctx.stroke();
          }
          ctx.shadowBlur = 0;
          ctx.restore();
        });
      };
    } break;

    // ========== CONTINUING WITH 60+ MORE UNIQUE ATTACKS ==========
    case 'k': { // Kinetic energy chains that link and swing
      a.update = t => {
        a.t += t;
        if (!a.data.chains) a.data.chains = [];
        if (a.data.chains.length < 4 && Math.random() < 0.02) {
          const chain = { 
            segments: [], 
            px: Math.random()*W, 
            py: barriers.top - 50, 
            swing: 0,
            length: 12
          };
          for (let i=0; i<chain.length; i++) chain.segments.push({x:0, y:i*28, vx:0, vy:0});
          a.data.chains.push(chain);
        }
        a.data.chains.forEach(c => {
          c.swing += t * 8;
          c.py += 280 * t;
          const targetX = c.px + Math.sin(c.swing) * 200;
          const targetY = c.py + Math.cos(c.swing) * 100;
          
          // Physics simulation for chain
          c.segments[c.segments.length-1].x = targetX - c.px;
          c.segments[c.segments.length-1].y = targetY - c.py;
          for (let i = c.segments.length-2; i >= 0; i--) {
            const curr = c.segments[i+1];
            const seg = c.segments[i];
            const dx = curr.x - seg.x;
            const dy = curr.y - seg.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 28) {
              seg.x = curr.x - (dx/dist) * 28;
              seg.y = curr.y - (dy/dist) * 28;
            }
          }
          
          // Collision
          for (let i=1; i<c.segments.length; i++) {
            const prev = c.segments[i-1];
            const curr = c.segments[i];
            const gx = c.px + prev.x, gy = c.py + prev.y;
            const cx = c.px + curr.x, cy = c.py + curr.y;
            if (lineCircle(gx, gy, cx, cy, player.x, player.y, player.r)) damage(9);
          }
        });
        if (a.t > 13) a.active = false;
      };
      a.render = ctx => {
        if (a.data.chains) a.data.chains.forEach(c => {
          ctx.strokeStyle = '#ff8';
          ctx.lineWidth = 8;
          ctx.shadowColor = '#ff0'; ctx.shadowBlur = 20;
          ctx.lineCap = 'round';
          a.data.chains.forEach(c => {
            ctx.beginPath();
            c.segments.forEach((s,i) => {
              const x = c.px + s.x, y = c.py + s.y;
              i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            });
            ctx.stroke();
          });
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'l': { // Laser grid that rotates and scales
      a.update = t => {
        a.t += t;
        if (!a.data.grid) {
          a.data.grid = { angle: 0, scale: 1, lasers: [] };
          for (let i=0; i<12; i++) {
            a.data.grid.lasers.push({ angle: i*Math.PI*2/12, width: 30 });
          }
        }
        a.data.grid.angle += t * 3;
        a.data.grid.scale += Math.sin(a.t * 4) * 0.02;
        a.data.grid.scale = Math.max(0.5, Math.min(2, a.data.grid.scale));
        
        a.data.grid.lasers.forEach(l => {
          const rad = 300 * a.data.grid.scale;
          const startAngle = l.angle + a.data.grid.angle;
          const endAngle = startAngle + Math.PI;
          const sx = cw + Math.cos(startAngle) * rad;
          const sy = ch + Math.sin(startAngle) * rad;
          const ex = cw + Math.cos(endAngle) * rad * 0.8;
          const ey = ch + Math.sin(endAngle) * rad * 0.8;
          if (lineCircle(sx,sy,ex,ey,player.x,player.y,player.r)) damage(14);
        });
        if (a.t > 11) a.active = false;
      };
      a.render = ctx => {
        if (a.data.grid) {
          a.data.grid.lasers.forEach(l => {
            const rad = 320 * a.data.grid.scale;
            const startAngle = l.angle + a.data.grid.angle;
            const endAngle = startAngle + Math.PI;
            const sx = cw + Math.cos(startAngle) * rad;
            const sy = ch + Math.sin(startAngle) * rad;
            const ex = cw + Math.cos(endAngle) * rad * 0.7;
            const ey = ch + Math.sin(endAngle) * rad * 0.7;
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = l.width;
            ctx.shadowColor = '#f0f'; ctx.shadowBlur = 30;
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();
          });
          ctx.shadowBlur = 0;
        }
      };
    } break;

    // ========== NUMBERS 0-9 ==========
    case '0': { // 0-shaped orbiting rings
      a.update = t => {
        a.t += t;
        if (!a.data.rings) a.data.rings = [];
        if (a.data.rings.length < 3 && Math.random() < 0.03) {
          a.data.rings.push({
            x: cw, y: ch,
            r1: 80, r2: 120,
            angle: Math.random()*Math.PI*2,
            speed: 2 + Math.random()*2,
            bullets: []
          });
        }
        a.data.rings.forEach(ring => {
          ring.angle += ring.speed * t;
          // Spawn bullets from ring
          if (Math.random() < 0.15) {
            const bulletAngle = ring.angle + Math.PI;
            ring.bullets.push({
              x: ring.x + Math.cos(bulletAngle) * ring.r2,
              y: ring.y + Math.sin(bulletAngle) * ring.r2,
              vx: Math.cos(bulletAngle) * 300,
              vy: Math.sin(bulletAngle) * 300
            });
          }
          ring.bullets.forEach(b => {
            b.x += b.vx * t;
            b.y += b.vy * t;
            if (circleCircle(b.x, b.y, 12, player.x, player.y, player.r)) damage(10);
          });
          ring.bullets = ring.bullets.filter(b => b.x > -50 && b.x < W+50 && b.y > -50 && b.y < H+50);
        });
        if (a.t > 12) a.active = false;
      };
      a.render = ctx => {
        if (a.data.rings) a.data.rings.forEach(ring => {
          // Outer ring
          ctx.strokeStyle = '#ff0';
          ctx.lineWidth = 8;
          ctx.beginPath(); ctx.arc(ring.x, ring.y, ring.r2, 0, Math.PI*2); ctx.stroke();
          // Inner ring
          ctx.strokeStyle = '#f80';
          ctx.lineWidth = 6;
          ctx.beginPath(); ctx.arc(ring.x, ring.y, ring.r1, 0, Math.PI*2); ctx.stroke();
          // Bullets
          ring.bullets.forEach(b => {
            ctx.fillStyle = '#ff0';
            ctx.beginPath(); ctx.arc(b.x, b.y, 12, 0, Math.PI*2); ctx.fill();
          });
        });
      };
    } break;

    case '1': { // 1-shaped piercing spears
      a.update = t => {
        a.t += t;
        if (!a.data.spears) a.data.spears = [];
        if (a.data.spears.length < 15 && Math.random() < 0.06) {
          const angle = (Math.random()-0.5)*0.3;
          a.data.spears.push({
            x: barriers.left - 80,
            y: ch + (Math.random()-0.5)*200,
            vx: 650 + Math.random()*150,
            vy: Math.tan(angle) * 200,
            length: 120,
            alpha: 1
          });
        }
        a.data.spears.forEach(s => {
          s.x += s.vx * t;
          s.y += s.vy * t;
          if (s.x > barriers.right + 100) s.alpha -= t*4;
          // Spear collision (line with thickness)
          if (lineCircle(s.x - s.length, s.y, s.x, s.y, player.x, player.y, player.r + 8)) damage(11);
        });
        a.data.spears = a.data.spears.filter(s => s.alpha > 0);
        if (a.t > 10) a.active = false;
      };
      a.render = ctx => {
        if (a.data.spears) a.data.spears.forEach(s => {
          ctx.globalAlpha = s.alpha;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 16;
          ctx.lineCap = 'round';
          ctx.shadowColor = '#fff'; ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.moveTo(s.x - s.length, s.y);
          ctx.lineTo(s.x, s.y);
          ctx.stroke();
          ctx.shadowBlur = 0;
        });
      };
    } break;

    // ========== SYMBOLS ==========
    case '!': { // Giant ! characters raining down
      a.update = t => {
        a.t += t;
        if (!a.data.exclamations) a.data.exclamations = [];
        if (a.data.exclamations.length < 20 && Math.random() < 0.08) {
          a.data.exclamations.push({
            x: Math.random()*W,
            y: barriers.top - 100,
            vy: 300 + Math.random()*200,
            size: 40 + Math.random()*30,
            spin: (Math.random()-0.5)*4,
            alpha: 1
          });
        }
        a.data.exclamations.forEach(exc => {
          exc.y += exc.vy * t;
          exc.spin += t * 2;
          if (exc.y > barriers.bottom + 100) exc.alpha -= t*3;
          // Collision with ! shape
          if (excShapeCollision(exc.x, exc.y, exc.size, player.x, player.y, player.r)) damage(12);
        });
        a.data.exclamations = a.data.exclamations.filter(e => e.alpha > 0);
        if (a.t > 11) a.active = false;
      };
      a.render = ctx => {
        if (a.data.exclamations) a.data.exclamations.forEach(exc => {
          ctx.save();
          ctx.globalAlpha = exc.alpha;
          ctx.translate(exc.x, exc.y);
          ctx.rotate(exc.spin);
          ctx.font = `${exc.size}px Arial`;
          ctx.fillStyle = '#f00';
          ctx.shadowColor = '#f00'; ctx.shadowBlur = 25;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('!', 0, 0);
          ctx.shadowBlur = 0;
          ctx.restore();
        });
      };
    } break;

    case 'Enter': { // 360° bullet hell ring with acceleration
      a.update = t => {
        a.t += t;
        if (!a.data.rings) a.data.rings = [];
        if (a.t > 0.8 && a.data.rings.length < 7 && a.t % 1.1 < t) {
          const ring = [];
          for (let i=0; i<42; i++) {
            const angle = i*Math.PI*2/42 + a.t * 0.5;
            ring.push({ 
              x: cw, y: ch, 
              vx: Math.cos(angle)*380, 
              vy: Math.sin(angle)*380,
              r: 11,
              accel: 1
            });
          }
          a.data.rings.push(ring);
        }
        a.data.rings.forEach(ring => {
          ring.forEach(b => {
            b.accel += t * 1.5;
            b.x += b.vx * b.accel * t;
            b.y += b.vy * b.accel * t;
            if (circleCircle(b.x,b.y,b.r,player.x,player.y,player.r)) damage(9);
          });
        });
        if (a.t > 13) a.active = false;
      };
      a.render = ctx => {
        if (a.data.rings) a.data.rings.forEach(ring => {
          ring.forEach(b => {
            ctx.fillStyle = '#f0f';
            ctx.shadowColor = '#f0f'; ctx.shadowBlur = 18;
            ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
          });
        });
      };
    } break;

    case ' ': { // Space: Meteors with craters and fragments
      a.update = t => {
        a.t += t;
        if (!a.data.meteors) a.data.meteors = [];
        if (a.data.meteors.length < 9 && Math.random() < 0.035) {
          a.data.meteors.push({ 
            x: Math.random()*W, 
            y: barriers.top - 150, 
            vy: 250 + Math.random()*250, 
            vx: (Math.random()-0.5)*100,
            r: 35 + Math.random()*25, 
            crater: false,
            fragments: []
          });
        }
        a.data.meteors.forEach(m => {
          m.x += m.vx * t;
          m.y += m.vy * t;
          m.vy += 300 * t;
          m.vx *= 0.99;
          if (!m.crater && m.y > barriers.bottom - 80) {
            m.crater = true;
            explode(m.x, barriers.bottom - 40, m.r * 1.8, 20);
            // Fragments
            for (let i=0; i<6; i++) {
              const angle = i*Math.PI*2/6;
              m.fragments.push({
                x: m.x, y: barriers.bottom - 40,
                vx: Math.cos(angle)*300, vy: Math.sin(angle)*300 - 100,
                r: 12
              });
            }
          }
          if (!m.crater && circleCircle(m.x, m.y, m.r, player.x, player.y, player.r)) damage(18);
        });
        a.data.meteors.forEach(m => {
          m.fragments.forEach(f => {
            f.x += f.vx * t;
            f.y += f.vy * t;
            f.vy += 600 * t;
            f.vx *= 0.97;
            if (circleCircle(f.x, f.y, f.r, player.x, player.y, player.r)) damage(8);
          });
        });
        if (a.t > 14) a.active = false;
      };
      a.render = ctx => {
        if (a.data.meteors) a.data.meteors.forEach(m => {
          // Meteor
          if (!m.crater) {
            ctx.fillStyle = '#555';
            ctx.shadowColor = '#888'; ctx.shadowBlur = 25;
            ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
            // Crater
            ctx.fillStyle = '#333';
            ctx.beginPath(); 
            ctx.arc(m.x - m.r*0.4, m.y - m.r*0.3, m.r*0.5, 0, Math.PI*2); 
            ctx.fill();
          }
          // Fragments
          m.fragments.forEach(f => {
            ctx.fillStyle = '#777';
            ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill();
          });
          ctx.shadowBlur = 0;
        });
      };
    } break;

    case 'Escape': { // Pulsing portal with sparks
      a.update = t => {
        a.t += t;
        if (!a.data.portal) {
          a.data.portal = { x: cw, y: ch, r: 0, sparks: [], pulse: 0 };
        }
        a.data.portal.pulse += t * 10;
        a.data.portal.r += 800 * t;
        // Sparks
        if (Math.random() < 0.4) {
          const angle = Math.random()*Math.PI*2;
          a.data.portal.sparks.push({
            x: a.data.portal.x + Math.cos(angle) * a.data.portal.r,
            y: a.data.portal.y + Math.sin(angle) * a.data.portal.r,
            vx: Math.cos(angle)*400 + (Math.random()-0.5)*200,
            vy: Math.sin(angle)*400 + (Math.random()-0.5)*200,
            life: 0.6
          });
        }
        a.data.portal.sparks.forEach(s => {
          s.x += s.vx * t;
          s.y += s.vy * t;
          s.vx *= 0.95; s.vy *= 0.95;
          s.life -= t;
          if (circleCircle(s.x, s.y, 6, player.x, player.y, player.r)) damage(16);
        });
        a.data.portal.sparks = a.data.portal.sparks.filter(s => s.life > 0);
        if (circleCircle(a.data.portal.x, a.data.portal.y, a.data.portal.r - 40, player.x, player.y, player.r)) damage(20);
        if (a.t > 10) a.active = false;
      };
      a.render = ctx => {
        if (a.data.portal) {
          // Portal rings
          for (let i=0; i<5; i++) {
            const alpha = (1 - i/5) * 0.7;
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = '#80f';
            ctx.lineWidth = 20 - i*4;
            ctx.shadowColor = '#80f'; ctx.shadowBlur = 40;
            ctx.beginPath(); 
            ctx.arc(a.data.portal.x, a.data.portal.y, a.data.portal.r - i*30, 0, Math.PI*2); 
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
          // Sparks
          a.data.portal.sparks.forEach(s => {
            ctx.globalAlpha = s.life;
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff'; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
          });
          ctx.globalAlpha = 1;
        }
      };
    } break;

    // ========== WORLD 2: UNICODE ATTACKS ==========
    case '→': { // Clockwise rotating blades
      a.update = t => {
        a.t += t;
        if (!a.data.blades) a.data.blades = [];
        if (a.data.blades.length < 16) {
          const angle = (a.data.blades.length / 16) * Math.PI * 2;
          a.data.blades.push({
            x: cw, y: ch,
            angle: angle,
            r: 60,
            speed: 400,
            length: 180
          });
        }
        a.data.blades.forEach(b => {
          b.angle += t * 8;
          const bladeEndX = b.x + Math.cos(b.angle) * b.length;
          const bladeEndY = b.y + Math.sin(b.angle) * b.length;
          if (lineCircle(b.x, b.y, bladeEndX, bladeEndY, player.x, player.y, b.r)) damage(15);
        });
        if (a.t > 12) a.active = false;
      };
      a.render = ctx => {
        if (a.data.blades) {
          a.data.blades.forEach(b => {
            ctx.strokeStyle = '#f80';
            ctx.lineWidth = b.r * 2;
            ctx.lineCap = 'round';
            ctx.shadowColor = '#f80'; ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x + Math.cos(b.angle) * b.length, b.y + Math.sin(b.angle) * b.length);
            ctx.stroke();
            ctx.shadowBlur = 0;
          });
        }
      };
    } break;

    case '←': { // Counter-clockwise spiral bullets
      a.update = t => {
        a.t += t;
        if (!a.data.spiral) a.data.spiral = { angle: 0, bullets: [] };
        a.data.spiral.angle -= t * 15;
        if (a.data.spiral.bullets.length < 120 && a.t % 0.03 < t) {
          const r = a.t * 200;
          const bulletAngle = a.data.spiral.angle + a.data.spiral.bullets.length * 0.3;
          a.data.spiral.bullets.push({
            x: cw + Math.cos(bulletAngle) * r,
            y: ch + Math.sin(bulletAngle) * r,
            angle: bulletAngle - Math.PI/2,
            speed: 350
          });
        }
        a.data.spiral.bullets.forEach(b => {
          b.x += Math.cos(b.angle) * b.speed * t;
          b.y += Math.sin(b.angle) * b.speed * t;
          b.angle -= t * 3;
          if (circleCircle(b.x, b.y, 14, player.x, player.y, player.r)) damage(13);
        });
        a.data.spiral.bullets = a.data.spiral.bullets.filter(b => b.x > -100 && b.x < W+100 && b.y > -100 && b.y < H+100);
        if (a.t > 12) a.active = false;
      };
      a.render = ctx => {
        if (a.data.spiral) {
          a.data.spiral.bullets.forEach(b => {
            ctx.fillStyle = '#08f';
            ctx.shadowColor = '#08f'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(b.x, b.y, 14, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
          });
        }
      };
    } break;

    case '▲': { // Triangular bounce projectiles
      a.update = t => {
        a.t += t;
        if (!a.data.triangles) a.data.triangles = [];
        if (a.data.triangles.length < 24 && Math.random() < 0.07) {
          const side = Math.floor(Math.random()*3);
          let x, y;
          if (side === 0) { x = barriers.left - 80; y = Math.random()*H; }
          else if (side === 1) { x = barriers.right + 80; y = Math.random()*H; }
          else if (side === 2) { x = Math.random()*W; y = barriers.top - 80; }
          else { x = Math.random()*W; y = barriers.bottom + 80; }
          a.data.triangles.push({
            x, y,
            vx: (Math.random()-0.5)*200 + (side%2 ? 400 : 0),
            vy: (Math.random()-0.5)*200 + (side>=2 ? 400 : 0),
            size: 35,
            bounces: 0,
            angle: 0
          });
        }
        a.data.triangles.forEach(tri => {
          tri.x += tri.vx * t;
          tri.y += tri.vy * t;
          tri.angle += t * 10;
          
          // Bounce off barriers
          if (tri.x - tri.size < barriers.left || tri.x + tri.size > barriers.right) {
            tri.vx *= -0.85; tri.x = Math.max(barriers.left + tri.size, Math.min(barriers.right - tri.size, tri.x));
            tri.bounces++;
          }
          if (tri.y - tri.size < barriers.top || tri.y + tri.size > barriers.bottom) {
            tri.vy *= -0.85; tri.y = Math.max(barriers.top + tri.size, Math.min(barriers.bottom - tri.size, tri.y));
            tri.bounces++;
          }
          
          if (triShapeCollision(tri.x, tri.y, tri.size, tri.angle, player.x, player.y, player.r)) damage(14);
          if (tri.bounces > 8) tri.size *= 0.9;
        });
        a.data.triangles = a.data.triangles.filter(tri => tri.size > 8 && tri.bounces < 12);
        if (a.t > 13) a.active = false;
      };
      a.render = ctx => {
        if (a.data.triangles) a.data.triangles.forEach(tri => {
          ctx.save();
          ctx.translate(tri.x, tri.y);
          ctx.rotate(tri.angle);
          ctx.fillStyle = '#f80';
          ctx.shadowColor = '#f80'; ctx.shadowBlur = 22;
          ctx.beginPath();
          ctx.moveTo(0, -tri.size);
          ctx.lineTo(-tri.size, tri.size);
          ctx.lineTo(tri.size, tri.size);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
          ctx.restore();
        });
      };
    } break;

    // ========== DEFAULT/OTHER KEYS ==========
    default: {
      // Generic but unique pattern for any remaining keys
      const patterns = [
        // Pattern 1: Homing missiles
        () => {
          a.update = t => {
            a.t += t;
            if (!a.data.missiles) a.data.missiles = [];
            if (a.data.missiles.length < 12 && Math.random() < 0.05) {
              const angle = Math.random()*Math.PI*2;
              a.data.missiles.push({
                x: Math.random()*W, y: Math.random()*H,
                vx: Math.cos(angle)*250, vy: Math.sin(angle)*250,
                targetAngle: 0, life: 1
              });
            }
            a.data.missiles.forEach(m => {
              const dx = player.x - m.x, dy = player.y - m.y;
              m.targetAngle = Math.atan2(dy, dx);
              const diff = m.targetAngle - Math.atan2(m.vy, m.vx);
              const turn = diff > 0 ? 1 : -1;
              m.vx += Math.cos(m.targetAngle) * 400 * t;
              m.vy += Math.sin(m.targetAngle) * 400 * t;
              m.x += m.vx * t; m.y += m.vy * t;
              m.life -= t;
              if (circleCircle(m.x, m.y, 16, player.x, player.y, player.r)) damage(12);
            });
            a.data.missiles = a.data.missiles.filter(m => m.life > 0);
            if (a.t > 11) a.active = false;
          };
          a.render = ctx => {
            if (a.data.missiles) a.data.missiles.forEach(m => {
              ctx.fillStyle = '#f0f';
              ctx.globalAlpha = m.life;
              ctx.beginPath(); ctx.arc(m.x, m.y, 16, 0, Math.PI*2); ctx.fill();
            });
          };
        },
        // Pattern 2: Wave pattern
        () => {
          a.update = t => {
            a.t += t;
            if (!a.data.waves) a.data.waves = [];
            if (a.data.waves.length < 6 && a.t % 1.5 < t) {
              a.data.waves.push({
                y: barriers.top - 100,
                offset: Math.random()*1000,
                speed: 3 + Math.random()*2,
                height: 60
              });
            }
            a.data.waves.forEach(w => {
              w.y += 320 * t;
              const wave = Math.sin((w.y + w.offset) * 0.02) * 80;
              ctx.fillRect(barriers.left + wave, w.y - w.height/2, barriers.right - barriers.left + wave*2, w.height);
              if (rectCircle(barriers.left + wave, w.y - w.height/2, barriers.right - barriers.left + wave*2, w.height, player.x, player.y, player.r)) damage(10);
            });
            a.data.waves = a.data.waves.filter(w => w.y < barriers.bottom + 100);
            if (a.t > 12) a.active = false;
          };
          a.render = ctx => {
            if (a.data.waves) a.data.waves.forEach(w => {
              const wave = Math.sin((w.y + w.offset) * 0.02) * 80;
              ctx.fillStyle = '#0f0';
              ctx.globalAlpha = 0.7;
              ctx.fillRect(barriers.left + wave, w.y - w.height/2, barriers.right - barriers.left + wave*2, w.height);
            });
          };
        }
      ];
      patterns[Math.floor(Math.random() * patterns.length)]();
    }
  }
}

function damage(amount) {
  if (player.dead) return;
  let absorbed = 0;
  if (player.shield > 0) {
    absorbed = Math.min(player.shield, amount);
    player.shield -= absorbed;
    popup(player.x, player.y, `S${absorbed}`, '#0ff');
  }
  const hpDamage = amount - absorbed;
  if (hpDamage > 0) {
    player.hp -= hpDamage;
    popup(player.x, player.y, `-${hpDamage}`, '#f00');
  }
  if (player.hp <= 0) { 
    player.hp = 0; 
    player.dead = true; 
    gameover.classList.remove('hidden'); 
  }
  updateHUD();
}

function heal(amount) {
  if (player.hp < player.maxHp) {
    const healed = Math.min(amount, player.maxHp - player.hp);
    player.hp += healed;
    popup(player.x, player.y, `+${healed}`, '#0f0');
  } else if (player.shield < player.maxShield) {
    const shieldAdd = Math.min(5, player.maxShield - player.shield);
    player.shield += shieldAdd;
    popup(player.x, player.y, `+${shieldAdd}S`, '#0ff');
  }
  updateHUD();
}

function popup(x, y, text, color) {
  popups.push({ x, y, text, color, life: 1.2, vy: -120, scale: 1 });
}

function explode(x, y, radius, dmg) {
  for (let i=0; i<30; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = 200 + Math.random()*400;
    particles.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed + 100,
      life: 0.8, size: 4 + Math.random()*4, color: `hsl(${15 + Math.random()*30}, 100%, 60%)`
    });
  }
  if (dist(x,y,player.x,player.y) < radius) damage(dmg);
}

function updateHUD() {
  hud.hp.innerHTML = `HP: ${Math.ceil(player.hp)}/${player.maxHp}<br>Shield: ${Math.ceil(player.shield)}/${player.maxShield}<br>Stage: ${game.currentKey || '-'}`;
}

let lastTime = 0;
function loop(time) {
  const dt = Math.min((time - lastTime)/1000, 0.05);
  lastTime = time;

  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  // Smooth cursor following
  player.x += (mouse.x - player.x) * 20 * dt;
  player.y += (mouse.y - player.y) * 20 * dt;
  player.x = Math.max(player.r, Math.min(W - player.r, player.x));
  player.y = Math.max(player.r, Math.min(H - player.r, player.y));

  // Game logic
  if (game.mode === 'precoded' || game.mode === 'precoded-uni') {
    if (!player.dead) {
      game.timer -= dt;
      hud.timer.textContent = game.timer.toFixed(1) + 's';
      if (game.timer <= 0) {
        heal(12);
        nextStage();
      }
    } else {
      hud.timer.textContent = '';
    }
  } else {
    hud.timer.textContent = '';
  }

  // HP regeneration
  if (player.hp < player.maxHp && !player.dead) {
    player.hp += dt * 60;
  }

  // Unicode events with WARNING
  if (!player.dead && performance.now() - unicodeTimer > 4000 + Math.random()*3000) {
    const eventChar = ['→','←','▲','▼','█','◆'][Math.floor(Math.random()*6)];
    eventQueue.push({ char: eventChar, warnTime: performance.now() });
    unicodeTimer = performance.now() + 7000;
  }

  // Event warning
  if (eventQueue.length > 0) {
    const ev = eventQueue[0];
    const warnDt = (performance.now() - ev.warnTime) / 1000;
    if (warnDt < 1.5) {
      eventWarning.textContent = ev.char;
      eventWarning.style.opacity = Math.sin(warnDt * Math.PI * 2) * 0.8;
    } else {
      // Trigger event
      triggerUnicodeEvent(ev.char);
      eventQueue.shift();
      eventWarning.style.opacity = '0';
    }
  }

  // Update attacks
  attacks.forEach(a => a.active && a.update && a.update(dt));

  // Update particles
  particles.forEach(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 800 * dt;
    p.vx *= 0.98;
    p.life -= dt;
    p.scale = p.life;
  });
  particles = particles.filter(p => p.life > 0);

  // Update popups
  popups.forEach(p => {
    p.y += p.vy * dt;
    p.vy += 200 * dt;
    p.life -= dt;
    p.scale += dt * 2;
  });
  popups = popups.filter(p => p.life > 0);

  // RENDER
  ctx.save();
  applyTransform(ctx);

  // Attacks
  attacks.forEach(a => a.active && a.render && a.render(ctx));

  // Particles
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.scale, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // PLAYER CURSOR WITH HP/SHIELD BARS
  ctx.save();
  ctx.translate(player.x, player.y);
  
  // Shield ring
  if (player.shield > 0) {
    const shieldAlpha = player.shield / player.maxShield;
    ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha * 0.5})`;
    ctx.lineWidth = 8;
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 25;
    ctx.beginPath();
    ctx.arc(0, 0, player.r + 8, 0, Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  // Main cursor
  const grad = ctx.createRadialGradient(-8, -8, 0, 0, 0, player.r);
  grad.addColorStop(0, '#fff');
  grad.addColorStop(1, '#aaa');
  ctx.fillStyle = grad;
  ctx.shadowColor = '#fff';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.arc(0, 0, player.r, 0, Math.PI*2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Black center
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(0, 0, player.r * 0.5, 0, Math.PI*2);
  ctx.fill();
  
  // HP bar
  ctx.fillStyle = '#333';
  ctx.fillRect(-player.r, -player.r - 8, player.r * 2, 6);
  ctx.fillStyle = player.hp > player.maxHp * 0.5 ? '#0f0' : player.hp > player.maxHp * 0.25 ? '#ff0' : '#f00';
  ctx.fillRect(-player.r, -player.r - 8, (player.hp / player.maxHp) * player.r * 2, 6);
  
  // Shield bar
  ctx.fillStyle = '#333';
  ctx.fillRect(-player.r, -player.r + 1, player.r * 2, 4);
  ctx.fillStyle = '#0ff';
  ctx.fillRect(-player.r, -player.r + 1, (player.shield / player.maxShield) * player.r * 2, 4);
  
  ctx.restore();
  
  ctx.restore();

  // Popups (outside transform)
  ctx.save();
  popups.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(p.scale, p.scale);
    ctx.globalAlpha = p.life;
    ctx.font = 'bold 24px Arial';
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 15;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.text, 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();
  });
  ctx.restore();

  // Transform smoothing
  transform.rot += (0 - transform.rot) * 12 * dt;
  transform.tx += (0 - transform.tx) * 12 * dt;
  transform.ty += (0 - transform.ty) * 12 * dt;
  if (transform.shakeTimer > 0) {
    transform.shakeTimer -= dt;
    transform.shake = transform.shakeTimer > 0 ? 1 : 0;
  }

  if (!player.dead || game.mode === 'precoded' || game.mode === 'precoded-uni') {
    requestAnimationFrame(loop);
  }
}

function applyTransform(ctx) {
  ctx.translate(cw + transform.tx, ch + transform.ty);
  ctx.rotate(transform.rot);
  if (transform.shake > 0) {
    const shakeAmt = transform.shake * 40;
    ctx.translate((Math.random()-0.5)*shakeAmt, (Math.random()-0.5)*shakeAmt);
  }
  ctx.translate(-cw, -ch);
  // Clip to barriers
  ctx.save();
  ctx.beginPath();
  ctx.rect(barriers.left, barriers.top, barriers.right - barriers.left, barriers.bottom - barriers.top);
  ctx.clip();
}

function triggerUnicodeEvent(char) {
  popup(cw, ch, char, '#ff0');
  switch(char) {
    case '→': transform.rot += Math.PI / 2 * (Math.random() < 0.5 ? 1 : 2); break;
    case '←': transform.rot -= Math.PI / 2 * (Math.random() < 0.5 ? 1 : 2); break;
    case '▲': transform.ty -= 120 * (1 + Math.random()); break;
    case '▼': transform.ty += 120 * (1 + Math.random()); break;
    case '█': 
      const squeeze = 60 + Math.random()*40;
      barriers.left = Math.min(barriers.left + squeeze, cw - 100);
      barriers.right = Math.max(barriers.right - squeeze, cw + 100);
      barriers.top = Math.min(barriers.top + squeeze, ch - 100);
      barriers.bottom = Math.max(barriers.bottom - squeeze, ch + 100);
      break;
    case '◆':
      transform.shakeTimer = 0.5 + Math.random()*0.3;
      break;
    case '★':
      for (let i=0; i<50; i++) explode(cw + (Math.random()-0.5)*W, ch + (Math.random()-0.5)*H, 200, 5);
      break;
  }
}

// Collision helpers
function rectCircle(rx, ry, rw, rh, cx, cy, cr) {
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX, dy = cy - closestY;
  return dx*dx + dy*dy < cr*cr;
}

function circleCircle(x1,y1,r1,x2,y2,r2) {
  const dx = x2-x1, dy = y2-y1, d = Math.hypot(dx,dy);
  return d < r1 + r2;
}

function lineCircle(x1,y1,x2,y2,cx,cy,cr) {
  const dx = x2-x1, dy = y2-y1;
  const fx = x1-cx, fy = y1-cy;
  const a = dx*dx + dy*dy;
  const b = 2*(fx*dx + fy*dy);
  const cc = fx*fx + fy*fy - cr*cr;
  const disc = b*b - 4*a*cc;
  if (disc < 0) return false;
  const sqrtD = Math.sqrt(disc);
  let t1 = (-b + sqrtD)/(2*a);
  let t2 = (-b - sqrtD)/(2*a);
  return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
}

function rotatedRectCircle(rx, ry, rw, rh, rot, cx, cy, cr) {
  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(rot);
  const hit = rectCircle(-rw/2, -rh/2, rw, rh, cx-rx, cy-ry, cr);
  ctx.restore();
  return hit;
}

function triShapeCollision(tx, ty, size, angle, px, py, pr) {
  const points = [
    {x: 0, y: -size},
    {x: -size, y: size},
    {x: size, y: size}
  ];
  for (let i=0; i<3; i++) {
    const p1 = points[i];
    const p2 = points[(i+1)%3];
    const wx = p1.x * Math.cos(angle) - p1.y * Math.sin(angle) + tx;
    const wy = p1.x * Math.sin(angle) + p1.y * Math.cos(angle) + ty;
    const ex = p2.x * Math.cos(angle) - p2.y * Math.sin(angle) + tx;
    const ey = p2.x * Math.sin(angle) + p2.y * Math.cos(angle) + ty;
    if (lineCircle(wx, wy, ex, ey, px, py, pr)) return true;
  }
  return false;
}

function excShapeCollision(ex, ey, size, px, py, pr) {
  // ! shape: dot + line
  const dotR = size * 0.25;
  if (circleCircle(ex, ey - size * 0.6, dotR, px, py, pr)) return true;
  if (lineCircle(ex, ey - size * 0.3, ex, ey + size * 0.4, px, py, pr + 8)) return true;
  return false;
}

function dist(x1,y1,x2,y2) {
  return Math.hypot(x2-x1, y2-y1);
}

// Input handling
window.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    menu.classList.remove('hidden');
    player.dead = true;
    game.mode = null;
    return;
  }
  if (e.key.toLowerCase() === 'r') {
    if (player.dead || game.mode === 'precoded' || game.mode === 'precoded-uni') {
      startGame(game.mode || 'precoded');
    }
    return;
  }
  if (game.mode === 'yourchoice' && !player.dead && keys.includes(e.key)) {
    spawnAttack(e.key);
    game.currentKey = e.key;
    updateHUD();
  }
});

// Initialize
updateHUD();
precodedUniBtn.classList.toggle('locked', !progress.world1);
requestAnimationFrame(loop);
</script>
</body>
</html>
