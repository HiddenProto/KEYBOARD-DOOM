<DOCUMENT filename="broken keyboard doom 1.txt">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>KEYBOARD DOOM — V3.0 (Checkpoints Fix & More Skins)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* Global Styles */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; touch-action:none; font-family: 'Inter', sans-serif; }
canvas { display:block; image-rendering:pixelated; cursor:none; }
#hud { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#fff; }
.topleft { position:absolute; top:10px; left:10px; font-size:14px; text-shadow: 0 0 5px #0f0; }
.centertop { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:18px; font-weight:bold; color: #ffeb3b; text-shadow: 0 0 8px #ffeb3b; }
.bottomcenter { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.8; }
.status { position:absolute; top:60px; left:10px; font-size:12px; text-shadow: 0 0 3px #fff; }
/* Menu & Game Over */
.menu, .gameover, .shop {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,.95); backdrop-filter: blur(5px);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    color:#fff; transition: opacity 0.3s;
}
.hidden { opacity:0; pointer-events:none; position:absolute; }
.menu h1, .shop h1 {
    font-size: 2.5rem; margin-bottom: 20px;
    color: #00ff44; text-shadow: 0 0 10px #00ff44;
    text-align: center;
}
.menu button, .shop button {
    background: #1e1e1e; border: 2px solid #00ff44; color: #00ff44;
    padding: 10px 20px; margin: 8px 0; border-radius: 8px;
    cursor: pointer; font-size: 16px; font-weight: bold;
    transition: all 0.2s ease-in-out;
    box-shadow: 0 0 5px #00ff44;
}
.menu button:hover, .shop button:hover {
    background: #00ff44; color: #000; box-shadow: 0 0 15px #00ff44;
    transform: translateY(-2px);
}
.menu button:disabled {
    background: #333; border-color: #555; color: #888; cursor: not-allowed;
    box-shadow: none; transform: none;
}
.error-msg { color: #f55; margin-top: 10px; font-weight: bold; }
/* Skins Shop Specifics */
.skin-card {
    background: #222;
    border: 1px solid #00ff44;
    border-radius: 8px;
    padding: 15px;
    margin: 10px;
    width: 250px;
    text-align: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 0 5px #00ff44;
}
.skin-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 15px #00ff44;
}
.skin-card h3 {
    font-size: 1.2rem;
    color: #ffeb3b;
    margin-bottom: 5px;
}
.skin-card p {
    font-size: 0.85rem;
    color: #bbb;
    min-height: 40px;
    margin-bottom: 10px;
}
.skin-card .preview {
    width: 40px;
    height: 40px;
    margin: 10px auto;
    border: 1px solid #444;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #111;
}
.skin-catalog {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-height: 70vh;
    overflow-y: auto;
}
/* Development Text */
.dev-text {
    position: absolute;
    bottom: 10px;
    font-size: 12px;
    opacity: 0.7;
    color: #00ff44;
    text-shadow: 0 0 3px #00ff44;
}
.dev-left { left: 10px; }
.dev-right { right: 10px; }
</style>
</head>
<body>
<!-- Canvas for Game Rendering -->
<canvas id="gameCanvas"></canvas>
<!-- Heads Up Display (HUD) -->
<div id="hud">
    <div class="topleft">
        MODE: <span id="waveInfo">Endless</span> | HP: <span id="hp"></span> | SHIELD: <span id="shield"></span><br>
        CREDITS: <span id="credits">0</span>
    </div>
    <div class="centertop">
        <span id="stageKey">?</span> | <span id="timer">0.0</span>s
    </div>
    <div class="bottomcenter">
        Press 'R' to return to menu (or 'R' at Game Over)
    </div>
    <div class="status" id="status"></div>
</div>
<!-- Main Menu -->
<div id="menu" class="menu">
    <h1>KEYBOARD DOOM</h1>
    <p id="creditsNote" style="font-size:12px; opacity:0.7; margin-bottom:20px;">Development Assisted by HARP & REX</p>
    <div id="main-menu-buttons">
        <button id="precodedBtn">Endless World 1: Alphanumeric</button>
        <button id="precodedUniBtn">Endless World 2: Symbols & Unicode</button>
    </div>
    <!-- Shop is placed below modes -->
    <button id="skinsShopBtn">Skins Shop</button>
    <button id="backToMenuBtn" style="display:none;">Back to Main Menu</button>
    <input type="text" id="cheatInput" style="position:absolute; top:10px; right:10px; width:120px; height:30px; opacity:0.8; font-size:12px; border:1px solid #00ff44; background:rgba(0,0,0,0.7); color:#00ff44; text-align:center;" placeholder="Code..." maxlength="6">
    <!-- Development Texts -->
    <div class="dev-text dev-left">Dodge and survive – pure adrenaline!</div>
</div>
<!-- Skins Shop Modal -->
<div id="shop" class="shop hidden">
    <h1>Skins Shop</h1>
    <span class="text-xl mb-4 text-yellow-400">Your Credits: <span id="shopCredits">0</span></span>
    <p style="text-align:center; opacity:0.8; color:#fff; margin-bottom:10px;">Hover over icon to preview!</p>
    <div class="skin-catalog" id="skinCatalog">
        <!-- Skin cards rendered here -->
    </div>
    <button id="shopBackBtn" class="mt-4">Back to Menu</button>
    <!-- Development Texts -->
    <div class="dev-text dev-left">Dodge and survive – pure adrenaline!</div>
</div>
<!-- Game Over Screen -->
<div id="gameover" class="gameover hidden">
    <h1>GAME OVER</h1>
    <p id="finalScore" class="text-xl mb-4 text-red-500"></p>
    <p class="text-lg text-gray-300">Press 'R' to restart</p>
</div>
<!-- Popup for transient messages (used instead of alert) -->
<div id="popup-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></div>
<script>
// --- CORE GAME CONSTANTS & CONFIGURATIONS ---
// World Segregation - World 1: Alphanumeric (36 stages)
const WORLD1_KEYS = [
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
];
// World 2 - Symbols, Functional Keys, and Unicodes (79+ stages)
const WORLD2_SYMBOLS = [
    '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '-', '=',
    '[', ']', '{', '}', '|', '\\', ';', ':', "'", '"', ',', '.', '<', '>', '?', '/',
    'Space', 'Enter', 'Tab', 'Shift', 'Control', 'Alt', 'CapsLock', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
];
const WORLD2_UNICODE = [
    '→', '←', '▲', '▼', '☆', '★', '⚡', '∞', 'π', 'Ω', 'Σ', 'Φ',
    '§', 'µ', '©', '®', '™', '€', '£', '¥', '¢', '°', '±', '÷', '×',
    '≠', '≈', '≤', '≥', '∫', '∂', '∇', '√', '∛', '∜', '…', '‘', '’', '“', '”', '¶'
];
const WORLD2_FULL = [...WORLD2_SYMBOLS, ...WORLD2_UNICODE];
const MAX_HP = 100;
const MAX_SHIELD = 100;
const BASE_CREDITS = 0;
const BONUS_CREDITS_PER_SEC = 5;
// --- PERIODIC TABLE DATA FOR SKIN ---
const PERIODIC_ELEMENT_DATA = [
    { num: 1, symbol: 'H', weight: 1.008, color: '#add8e6', name: 'Hydrogen' }, // Non-metal
    { num: 2, symbol: 'He', weight: 4.002, color: '#fffacd', name: 'Helium' }, // Noble gas
    { num: 6, symbol: 'C', weight: 12.011, color: '#3cb371', name: 'Carbon' }, // Non-metal
    { num: 8, symbol: 'O', weight: 15.999, color: '#f08080', name: 'Oxygen' }, // Non-metal
    { num: 11, symbol: 'Na', weight: 22.990, color: '#8a2be2', name: 'Sodium' }, // Alkali metal
    { num: 17, symbol: 'Cl', weight: 35.453, color: '#90ee90', name: 'Chlorine' }, // Halogen
    { num: 19, symbol: 'K', weight: 39.098, color: '#9370db', name: 'Potassium' }, // Alkali metal
    { num: 26, symbol: 'Fe', weight: 55.845, color: '#bdb76b', name: 'Iron' }, // Transition metal
    { num: 29, symbol: 'Cu', weight: 63.546, color: '#b8860b', name: 'Copper' }, // Transition metal
    { num: 47, symbol: 'Ag', weight: 107.87, color: '#c0c0c0', name: 'Silver' }, // Transition metal
    { num: 79, symbol: 'Au', weight: 196.97, color: '#ffd700', name: 'Gold' }, // Transition metal
    { num: 80, symbol: 'Hg', weight: 200.59, color: '#cccccc', name: 'Mercury' }, // Transition metal
];
function getRandomPeriodicElement() {
    return PERIODIC_ELEMENT_DATA[Math.floor(Math.random() * PERIODIC_ELEMENT_DATA.length)];
}
// --- GAME STATE AND PROGRESS OBJECTS ---
const player = {
    x: 0, y: 0, radius: 10, speed: 4,
    hp: MAX_HP, maxHp: MAX_HP, shield: 0,
    dead: false,
    credits: 0,
    equippedSkinId: 'default',
    skinState: { // For dynamic skins
        catNextChangeTime: 0,
        catFace: 'owo',
        periodicElement: PERIODIC_ELEMENT_DATA[0] // Initialize with H
    }
};
const game = {
    mode: 'menu', // 'menu', 'playing'
    world: 'world1', // 'world1', 'world2'
    stageKey: '?',
    survivalTime: 0,
    score: 0,
    attacks: [],
    diggers: [],
    shake: 0,
    lastTime: 0,
    lastDamageTime: 0,
    animationFrameId: null // To store the ID of requestAnimationFrame
};
let progress = {
    ownedSkins: ['default'],
    equippedSkinId: 'default',
    credits: 0
};
let previewStates = {}; // For skin preview animations
const appId = 'keyboard-doom-v3';
// --- LOCALSTORAGE PERSISTENCE FUNCTIONS ---
function saveProgress() {
    progress.equippedSkinId = player.equippedSkinId; // Save equipped skin
    progress.credits = player.credits; // Ensure credits are saved
    localStorage.setItem(appId + '_progress', JSON.stringify(progress));
    localStorage.setItem(appId + '_credits', player.credits.toString());
    localStorage.setItem(appId + '_equippedSkin', player.equippedSkinId);
}
function loadProgress() {
    const localProgress = localStorage.getItem(appId + '_progress');
    const localCredits = localStorage.getItem(appId + '_credits');
    const localSkin = localStorage.getItem(appId + '_equippedSkin');
    if (localProgress) {
        progress = JSON.parse(localProgress);
    }
    if (localCredits) {
        player.credits = parseInt(localCredits);
    }
    if (localSkin) {
        player.equippedSkinId = localSkin;
    }
    updateHUD();
}
// --- UTILITY AND DRAWING FUNCTIONS ---
function showPopup(text, x, y, duration, color = '#fff') {
    const container = document.getElementById('popup-container');
    const popup = document.createElement('div');
    popup.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: ${y}px;
        transform: translate(-50%, -50%);
        padding: 5px 10px;
        background: ${color};
        color: #000;
        border-radius: 5px;
        font-size: 16px;
        font-weight: bold;
        opacity: 1;
        transition: all 0.5s ease-out;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    `;
    popup.textContent = text;
    container.appendChild(popup);
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.top = (y - 50) + 'px';
        setTimeout(() => popup.remove(), 500);
    }, duration);
}
function updateHUD() {
    let worldDisplay = game.world === 'world1' ? 'Endless 1' : 'Endless 2';
    document.getElementById('waveInfo').textContent = worldDisplay;
    document.getElementById('hp').textContent = Math.ceil(player.hp);
    document.getElementById('shield').textContent = Math.ceil(player.shield);
    document.getElementById('credits').textContent = player.credits;
    document.getElementById('stageKey').textContent = game.stageKey.toUpperCase(); // Show key in caps
    document.getElementById('timer').textContent = game.survivalTime.toFixed(1);
    document.getElementById('shopCredits').textContent = player.credits; // Update shop display
}
function startShake(duration, intensity) {
    game.shake = intensity;
    setTimeout(() => game.shake = 0, duration);
}
// --- PLAYER AND SKIN LOGIC ---
// Skin Catalog
const SKIN_CATALOG = [
    { id: 'default', name: 'Base Dodecahedron', type: 'Static Glyph', price: 0, desc: 'The reliable geometry that protects you. Simple, robust, boring.', preview: '●', color: '#00ff44' },
    { id: 'retro_term', name: 'Vintage Terminal', type: 'Pixel/Trail Effect', price: 800, desc: 'Renders the player as a flashing green cursor block, leaving behind a brief ghost trail of \'console output\' text.', preview: '█', color: '#00ff00' },
    { id: 'star_map', name: 'Cosmic Starmap', type: 'Particle Cluster', price: 1800, desc: 'A swirling constellation of tiny stars that react to your movement.', preview: '✨', color: '#ffffff' },
    { id: 'cat_txt', name: 'cat.txt', type: 'Animated Text', price: 1500, desc: 'A glitching, animated text box that communicates its status via classic emoticon faces (owo, -w-, ;w;).', preview: 'owo', color: '#ffb300' },
    { id: 'shards', name: 'Flickering Shards', type: 'Dynamic Geometry', price: 2500, desc: 'The player breaks into small, flickering geometric shards when hit, unifying on recovery.', preview: '⬢', color: '#ff00ff' },
    { id: 'periodic', name: 'Periodic Table', type: 'Styled Box/Text', price: 2200, desc: 'Transforms into a color-coded element block, showing atomic data.', preview: 'Au', color: '#00ffff' },
    { id: 'dino_mode', name: 'Dinosaur Mode', type: 'Emoji', price: 500, desc: 'Transforms you into a majestic, low-cost dinosaur icon.', preview: '🦖', color: '#00cc00' },
    { id: 'hex_burst', name: 'Hex Code Burst', type: 'Dynamic Geometry', price: 3500, desc: 'The player is drawn as a cluster of constantly changing 6-digit hexadecimal color codes (based on player HP/shield status).', preview: '#A3FF4B', color: '#ff00ff' },
    { id: 'neon_glow', name: 'Neon Glow', type: 'Glowing Outline', price: 1200, desc: 'A pulsating neon outline that leaves a faint glow trail effect.', preview: '⟡', color: '#ff00ff' },
    { id: 'glitch', name: 'Glitch Effect', type: 'Distorted Render', price: 1600, desc: 'Player render with RGB split and scanline distortion.', preview: '█', color: '#ff0000' },
    { id: 'matrix_code', name: 'Matrix Code', type: 'Falling Code', price: 2000, desc: 'Surrounded by orbiting binary code digits.', preview: '01', color: '#00ff00' },
    { id: 'plasma_orbs', name: 'Plasma Orbs', type: 'Orbital Particles', price: 2800, desc: 'Multiple plasma orbs orbiting the core with electric arcs.', preview: '⚡', color: '#ff1493' },
    { id: 'cyber_grid', name: 'Cyber Grid', type: 'Wireframe', price: 900, desc: 'A holographic wireframe grid that rotates and pulses.', preview: '▱', color: '#00ffff' },
    { id: 'firefly_swarm', name: 'Firefly Swarm', type: 'Swarming Lights', price: 1900, desc: 'A swarm of tiny fireflies that flicker and follow movement patterns.', preview: '🪰', color: '#ffff00' },
    { id: 'void_portal', name: 'Void Portal', type: 'Swirling Vortex', price: 3200, desc: 'A dark portal that sucks in light and emits shadowy tendrils.', preview: '🌀', color: '#4b0082' },
    { id: 'sunflare', name: 'Sunflare', type: 'Radiant Burst', price: 1400, desc: 'Solar flare effects with coronal mass ejections.', preview: '☀️', color: '#ffd700' },
    { id: 'ice_crystal', name: 'Ice Crystal', type: 'Fractal Snow', price: 1100, desc: 'Growing ice fractals that shimmer with frost.', preview: '❄️', color: '#add8e6' },
    { id: 'lava_flow', name: 'Lava Flow', type: 'Molten', price: 2300, desc: 'Slow-flowing lava with bubbling embers.', preview: '🌋', color: '#ff4500' },
    { id: 'neural_net', name: 'Neural Net', type: 'Synaptic', price: 3000, desc: 'Interconnected neural nodes firing signals.', preview: '🧠', color: '#9370db' },
    { id: 'quantum_flux', name: 'Quantum Flux', type: 'Waveform Interference', price: 3800, desc: 'Overlapping quantum waves that interfere and create probabilistic patterns.', preview: '⟐', color: '#8a2be2' },
    { id: 'arcade_pixel', name: 'Arcade Pixel', type: 'Retro Sprite', price: 600, desc: '8-bit pixel art sprite with dithering and scanlines.', preview: '⬜', color: '#ff69b4' },
    { id: 'steampunk_gear', name: 'Steampunk Gear', type: 'Mechanical', price: 1700, desc: 'Brass gears and pistons with steam exhaust effects.', preview: '⚙️', color: '#cd7f32' },
    { id: 'bioluminescent', name: 'Bioluminescent', type: 'Organic Glow', price: 2100, desc: 'Glowing jellyfish-like tendrils that pulse with bioluminescence.', preview: '🌊', color: '#00ced1' },
    { id: 'holo_cube', name: 'Holo Cube', type: '3D Projection', price: 2900, desc: 'Rotating holographic cube with wireframe edges.', preview: '⬞', color: '#87ceeb' },
    { id: 'shadow_puppeteer', name: 'Shadow Puppeteer', type: 'Silhouette', price: 1300, desc: 'Dynamic shadow puppet that morphs shapes.', preview: '🖤', color: '#000000' },
    { id: 'electric_arc', name: 'Electric Arc', type: 'Lightning', price: 2400, desc: 'Crackling electric arcs that chain between nodes.', preview: '⚡', color: '#ffff00' },
    { id: 'flame_wisp', name: 'Flame Wisp', type: 'Ethereal Fire', price: 1500, desc: 'Floating flame wisps that trail embers.', preview: '🔥', color: '#ff4500' },
    { id: 'thorn_vine', name: 'Thorn Vine', type: 'Organic Growth', price: 1800, desc: 'Twisting thorn vines that grow and retract.', preview: '🌿', color: '#228b22' },
    { id: 'echo_waveform', name: 'Echo Waveform', type: 'Audio Visualizer', price: 2700, desc: 'Oscillating waveforms that echo with sound-like pulses.', preview: '∿', color: '#ff1493' },
    { id: 'grok_xai', name: 'GROK x.AI', type: 'Animated Black Hole', price: 0, desc: 'A swirling black hole with orbiting particles, crafted with assistance from Grok xAI.', preview: '🕳️', color: '#ffffff' }
];
function drawSkin(drawCtx, x, y, radius, skinId, skinState, hp, maxHp, lastDamageTime) {
    const skin = SKIN_CATALOG.find(s => s.id === skinId);
    if (!skin) return;
    const time = Date.now();
    const pulse = 1 + Math.sin(time / 800) * 0.1;
    const isDamaged = hp < maxHp * 0.5 || (lastDamageTime && time - lastDamageTime < 700);
    drawCtx.save();
    drawCtx.translate(x, y);
    drawCtx.fillStyle = skin.color;
    drawCtx.strokeStyle = '#fff';
    drawCtx.lineWidth = 2;
    switch (skinId) {
        case 'default':
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.stroke();
            break;
        case 'cat_txt':
            const catFace = skinState ? skinState.catFace : 'owo';
            drawCtx.font = 'bold 24px Inter';
            drawCtx.textAlign = 'center';
            drawCtx.fillText(catFace, 0, 8);
            drawCtx.strokeText(catFace, 0, 8);
            break;
        case 'periodic':
            const element = skinState && skinState.periodicElement || getRandomPeriodicElement();
            const elementSize = 30 * pulse;
            const elementBorderColor = '#333';
 
            drawCtx.save();
            drawCtx.scale(pulse, pulse);
            drawCtx.translate(-elementSize / (2 * pulse), -elementSize / (2 * pulse)); // Adjust for scale
 
            // 1. Draw Element Background and Border
            drawCtx.fillStyle = element.color || '#cccccc';
            drawCtx.fillRect(0, 0, elementSize / pulse, elementSize / pulse);
 
            drawCtx.strokeStyle = elementBorderColor;
            drawCtx.lineWidth = 1.5;
            drawCtx.strokeRect(0, 0, elementSize / pulse, elementSize / pulse);
 
            // 2. Draw Atomic Number (Top Left)
            drawCtx.font = `${7 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'left';
            drawCtx.fillText(element.num.toString(), 2, 8);
 
            // 3. Draw Symbol (Center)
            drawCtx.font = `bold ${15 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'center';
            drawCtx.fillText(element.symbol, (elementSize / (2 * pulse)), (elementSize / (2 * pulse)) + 5);
 
            // 4. Draw Atomic Weight (Bottom Center)
            drawCtx.font = `${6 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'center';
            drawCtx.fillText(element.weight.toFixed(3), (elementSize / (2 * pulse)), elementSize / pulse - 3);
            drawCtx.restore();
            break;
 
        case 'dino_mode':
            drawCtx.font = 'bold 24px Inter';
            drawCtx.textAlign = 'center';
            drawCtx.fillText('🦖', 0, 8);
            break;
        case 'retro_term':
            drawCtx.fillRect(-radius, -radius, radius * 2, radius * 2);
            // Simple flashing effect
            if (Math.floor(time / 200) % 2 === 0) {
                drawCtx.strokeStyle = '#000';
                drawCtx.strokeRect(-radius, -radius, radius * 2, radius * 2);
            }
            break;
 
        case 'shards':
            if (isDamaged) {
                // Flicker and draw as small scattered triangles
                if (Math.floor(time / 50) % 2 === 0) {
                    drawCtx.globalAlpha = 0.6;
                }
                for(let i=0; i<5; i++) {
                    const angle = i * Math.PI / 2.5;
                    drawCtx.save();
                    drawCtx.rotate(angle);
                    drawCtx.translate(Math.random()*4 - 2, Math.random()*4 - 2);
                    drawCtx.beginPath();
                    drawCtx.moveTo(radius, 0);
                    drawCtx.lineTo(radius * -0.5, radius * 0.866);
                    drawCtx.lineTo(radius * -0.5, radius * -0.866);
                    drawCtx.closePath();
                    drawCtx.fill();
                    drawCtx.stroke();
                    drawCtx.restore();
                }
                drawCtx.globalAlpha = 1;
            } else {
                // Draw as a solid hexagon when healthy
                drawCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const px = radius * Math.cos(angle);
                    const py = radius * Math.sin(angle);
                    if (i === 0) drawCtx.moveTo(px, py);
                    else drawCtx.lineTo(px, py);
                }
                drawCtx.closePath();
                drawCtx.fill();
                drawCtx.stroke();
            }
            break;
 
        case 'star_map':
            const starCount = 20;
            drawCtx.globalAlpha = 0.8;
            for (let i = 0; i < starCount; i++) {
                // Simple sine-wave movement for twinkling/swirling
                const angle = (i * 0.3) + (time * 0.001);
                const r = radius * 0.8 + Math.sin(time * 0.005 + i) * 2;
                const starSize = 1 + Math.random() * 1.5;
                drawCtx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, starSize, starSize);
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'hex_burst':
            const baseColor = (hp > 50) ? '#00FF00' : (hp > 20 ? '#FFFF00' : '#FF0000');
            const hexPulse = Math.sin(time / 300) * 0.3 + 0.7;
            drawCtx.fillStyle = baseColor;
            drawCtx.globalAlpha = hexPulse;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.7 * hexPulse, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            // Draw more hex codes, rotating and pulsing
            for(let i=0; i<12; i++) { // More codes
                const angle = i * Math.PI / 6 + time * 0.002; // Faster rotation
                const offset = radius * (1.5 + Math.sin(time / 500 + i) * 0.5); // Pulsing offset
                const hexCode = Math.floor(Math.random()*16777215).toString(16).padStart(6, '0').toUpperCase();
                const size = 6 + Math.sin(time / 200 + i) * 2; // Pulsing size
                drawCtx.font = `${size}px Inter`;
                drawCtx.fillStyle = `hsl(${ (time / 100) % 360 }, 100%, 50%)`; // Rainbow colors
                drawCtx.textAlign = 'center';
                drawCtx.textBaseline = 'middle';
                drawCtx.fillText('#' + hexCode, Math.cos(angle) * offset, Math.sin(angle) * offset);
            }
            // Add trail effect
            drawCtx.globalAlpha = 0.3;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
            drawCtx.strokeStyle = baseColor;
            drawCtx.lineWidth = 2;
            drawCtx.stroke();
            drawCtx.globalAlpha = 1;
            break;
        case 'neon_glow':
            drawCtx.shadowColor = skin.color;
            drawCtx.shadowBlur = 20 + Math.sin(time / 200) * 5;
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 3;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.stroke();
            drawCtx.shadowBlur = 0;
            break;
        case 'glitch':
            // RGB split effect with animation
            const glitchOffset = Math.sin(time / 300) * 2;
            // Red
            drawCtx.save();
            drawCtx.translate(glitchOffset, 0);
            drawCtx.fillStyle = '#f00';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.restore();
            // Blue
            drawCtx.save();
            drawCtx.translate(-glitchOffset, Math.sin(time / 400));
            drawCtx.fillStyle = '#00f';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.restore();
            // Green
            drawCtx.fillStyle = '#0f0';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            break;
        case 'matrix_code':
            // Orbiting binary digits
            drawCtx.fillStyle = '#000';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillStyle = skin.color;
            drawCtx.font = '10px monospace';
            drawCtx.textAlign = 'center';
            drawCtx.textBaseline = 'middle';
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + (time * 0.002);
                const r = radius + 10 + i * 3;
                const char = Math.random() > 0.5 ? '0' : '1';
                drawCtx.fillText(char, Math.cos(angle) * r, Math.sin(angle) * r);
            }
            break;
        case 'plasma_orbs':
            // Orbiting orbs with arcs
            for (let i = 0; i < 3; i++) {
                const angle = (i * Math.PI * 2 / 3) + (time * 0.003);
                const r = radius + 15;
                drawCtx.beginPath();
                drawCtx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 4, 0, Math.PI * 2);
                drawCtx.fill();
                // Arc to center
                drawCtx.strokeStyle = skin.color;
                drawCtx.lineWidth = 1;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                drawCtx.stroke();
            }
            break;
        case 'cyber_grid':
            // Rotating wireframe
            drawCtx.save();
            drawCtx.rotate(time * 0.001);
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    drawCtx.beginPath();
                    drawCtx.moveTo(i * radius, j * radius);
                    drawCtx.lineTo(0, 0);
                    drawCtx.stroke();
                }
            }
            drawCtx.restore();
            break;
        case 'firefly_swarm':
            // Flickering dots
            drawCtx.globalAlpha = 0.7;
            for (let i = 0; i < 15; i++) {
                const angle = i * 0.4 + time * 0.004;
                const r = radius * 0.5 + Math.sin(time * 0.01 + i) * 5;
                const alpha = 0.5 + Math.sin(time * 0.02 + i) * 0.5;
                drawCtx.globalAlpha = alpha;
                drawCtx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, 2, 2);
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'void_portal':
            // Swirling darkness with pulse and idle tendrils
            drawCtx.save();
            drawCtx.scale(pulse, pulse);
            const gradient = drawCtx.createRadialGradient(0, 0, 0, 0, 0, radius * 2 / pulse);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, skin.color);
            drawCtx.fillStyle = gradient;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 2 / pulse, 0, Math.PI * 2);
            drawCtx.fill();
            // Add swirling tendrils
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4 + time * 0.01;
                const r = radius * 0.5 / pulse;
                drawCtx.strokeStyle = '#fff';
                drawCtx.lineWidth = 1;
                drawCtx.globalAlpha = 0.3 + Math.sin(time * 0.02 + i) * 0.2;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            drawCtx.restore();
            break;
        case 'sunflare':
            // Radiant rays
            drawCtx.fillStyle = '#fff';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
            drawCtx.fill();
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4 + time * 0.005;
                drawCtx.strokeStyle = skin.color;
                drawCtx.lineWidth = 2;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * radius * 2, Math.sin(angle) * radius * 2);
                drawCtx.stroke();
            }
            break;
        case 'ice_crystal':
            // Fractal lines
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 2;
            function drawBranch(len, angle) {
                if (len < 2) return;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                drawCtx.stroke();
                drawBranch(len * 0.7, angle + 0.3);
                drawBranch(len * 0.7, angle - 0.3);
            }
            for (let i = 0; i < 6; i++) {
                drawBranch(radius, i * Math.PI / 3);
            }
            break;
        case 'grok_xai':
            // Simple black hole swirl
            const gradient2 = drawCtx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.5);
            gradient2.addColorStop(0, '#000');
            gradient2.addColorStop(0.7, '#111');
            gradient2.addColorStop(1, '#333');
            drawCtx.fillStyle = gradient2;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
            drawCtx.fill();
            // Orbiting particles
            for (let i = 0; i < 12; i++) {
                const angle = i * Math.PI / 6 + time * 0.005;
                const r = radius + 8;
                drawCtx.fillStyle = '#fff';
                drawCtx.beginPath();
                drawCtx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 1.5, 0, Math.PI * 2);
                drawCtx.fill();
            }
            break;
    }
    drawCtx.restore();
}
function renderPlayerSkin(dt) {
    const now = Date.now();
    // FIXED: Cat blink cycle to random 1-2s duration loop
    if (player.equippedSkinId === 'cat_txt') {
        if (!player.skinState.catNextChangeTime) {
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
        if (now > player.skinState.catNextChangeTime) {
            player.skinState.catFace = (player.skinState.catFace === 'owo') ? '-w-' : 'owo';
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
        // Damage/Low HP State (Override)
        const lowHp = player.hp < player.maxHp * 0.3;
        const recentDamage = game.lastDamageTime && (now - game.lastDamageTime < 500);
        if (lowHp || recentDamage) {
            player.skinState.catFace = ';w;';
            player.skinState.catNextChangeTime = now + 3000; // Hold for 3s during damage
        } else if (player.skinState.catFace === ';w;') {
            player.skinState.catFace = 'owo';
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
    }
    if (player.equippedSkinId === 'periodic') {
        if (Math.random() < 0.001) { // Rare change
            player.skinState.periodicElement = getRandomPeriodicElement();
        }
    }
    drawSkin(ctx, player.x, player.y, player.radius, player.equippedSkinId, player.skinState, player.hp, player.maxHp, game.lastDamageTime);
}
// --- PREVIEW FUNCTIONS ---
function drawStaticPreview(skinId) {
    const previewCanvas = document.getElementById(`preview-${skinId}`);
    if (!previewCanvas) return;
    const pCtx = previewCanvas.getContext('2d');
    pCtx.clearRect(0, 0, 40, 40);
    const skin = SKIN_CATALOG.find(s => s.id === skinId);
    if (!skin) return;
    pCtx.fillStyle = skin.color;
    pCtx.font = 'bold 20px Inter';
    pCtx.textAlign = 'center';
    pCtx.textBaseline = 'middle';
    pCtx.fillText(skin.preview, 20, 20);
}
function animatePreview(skinId, card) {
    const previewCanvas = document.getElementById(`preview-${skinId}`);
    if (!previewCanvas) return;
    const pCtx = previewCanvas.getContext('2d');
    let previewState = previewStates[skinId];
    if (!previewState) {
        previewStates[skinId] = {
            catNextChangeTime: 0,
            catFace: 'owo',
            periodicElement: getRandomPeriodicElement()
        };
        previewState = previewStates[skinId];
    }
    let animId;
    let lastPreviewTime = performance.now();
    function previewLoop(currentTime) {
        const previewDt = currentTime - lastPreviewTime;
        lastPreviewTime = currentTime;
        const pnow = Date.now();
        // Update state for dynamic skins
        if (skinId === 'cat_txt') {
            if (!previewState.catNextChangeTime) {
                previewState.catNextChangeTime = pnow + (1000 + Math.random() * 1000);
            }
            if (pnow > previewState.catNextChangeTime) {
                previewState.catFace = (previewState.catFace === 'owo') ? '-w-' : 'owo';
                previewState.catNextChangeTime = pnow + (1000 + Math.random() * 1000);
            }
            // No damage in preview
        }
        // Clear and draw
        pCtx.clearRect(0, 0, 40, 40);
        drawSkin(pCtx, 20, 20, 8, skinId, previewState, 100, 100, 0);
        // Continue if still hovering
        if (card.matches(':hover')) {
            animId = requestAnimationFrame(previewLoop);
        } else {
            cancelAnimationFrame(animId);
            drawStaticPreview(skinId);
        }
    }
    animId = requestAnimationFrame(previewLoop);
}
// --- DIGGER SPAWNING AND LOGIC ---
function spawnDigger() {
    const cw = canvas.width, ch = canvas.height;
    const digger = {
        x: Math.random() * cw,
        y: ch + 50,
        vx: (Math.random() - 0.5) * 0.5,
        vy: -1.2,
        size: 12,
        damage: 20,
        color: '#8B4513',
        lifetime: 15000, // 15 seconds max
        update: function(dt) {
            // Simple homing towards player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 50) {
                this.vx += (dx / dist) * 0.001 * dt;
                this.vy += (dy / dist) * 0.001 * dt;
            }
            this.x += this.vx * dt / 16;
            this.y += this.vy * dt / 16;
            this.lifetime -= dt;
        }
    };
    game.diggers.push(digger);
}
// --- ATTACK ARCHITECTURE (Unique Attack Registry - UAR) ---
// Base Attack Structure
function createAttack(x, y, vx, vy, color, radius, damage, lifetime = Infinity, type = 'basic') {
    return { x, y, vx, vy, color, radius, damage, lifetime, type };
}
// Unique Attack Functions - World 1 Examples
function spawn_A_attack() { // A: Accelerating Aperture (Homing to Center)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const angle = i * Math.PI / 2;
        const x = cw / 2 + Math.cos(angle) * 300;
        const y = ch / 2 + Math.sin(angle) * 300;
        const vx = Math.cos(angle) * 0.5;
        const vy = Math.sin(angle) * 0.5;
        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#ff0000', 8, 10, 8000),
            update: function(dt) {
                // Accelerate towards center
                const dx = cw / 2 - this.x;
                const dy = ch / 2 - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 100) {
                    this.vx += (dx / dist) * 0.005;
                    this.vy += (dy / dist) * 0.005;
                }
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.lifetime -= dt;
            }
        });
    }
}
function spawn_B_attack() { // B: Straight-line Stream (Fixed Trajectory)
    const cw = canvas.width, ch = canvas.height;
    const speed = 2.0;
    // Spawn 6 projectiles from random locations near the edge
    for (let i = 0; i < 6; i++) {
        let x, y;
        // Determine if spawning from horizontal (top/bottom) or vertical (left/right) edges
        if (Math.random() < 0.5) {
            x = Math.random() * cw;
            y = Math.random() < 0.5 ? 0 : ch;
        } else {
            x = Math.random() < 0.5 ? 0 : cw;
            y = Math.random() * ch;
        }
        // Calculate straight trajectory towards player's current position (snapshot at spawn)
        const dx = player.x - x;
        const dy = player.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;
        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#ff9900', 7, 8, 8000),
            // Minimal update: just handle the lifetime. vx/vy remain constant.
            update: function(dt) {
                this.lifetime -= dt;
            }
        });
    }
}
function spawn_C_attack() { // C: Angular Sweep (Rotating Laser Grid)
    const cw = canvas.width, ch = canvas.height;
    const center_x = cw / 2;
    const center_y = ch / 2;
    const count = 2; // Reduced to 2 beams for better balance
    const thickness = 10;
    const angularSpeed = 0.0005; // radians per millisecond (slow rotation)
    for (let i = 0; i < count; i++) {
        const initialAngle = i * Math.PI / count; // 0 and PI (180 deg)
        const laserLength = Math.max(cw, ch) * 2;
        game.attacks.push({
            x: center_x,
            y: center_y,
            vx: 0,
            vy: 0,
            color: '#ff00cc',
            radius: thickness / 2,
            damage: 10,
            lifetime: 15000,
            type: 'laser',
            width: thickness,
            length: laserLength,
            angle: initialAngle,
 
            update: function(dt) {
                // Rotate the laser line
                this.angle += angularSpeed * dt;
                this.lifetime -= dt;
            },
 
            draw: function(drawCtx) {
                drawCtx.save();
                drawCtx.translate(this.x, this.y);
                drawCtx.rotate(this.angle);
 
                // Draw beam as a long, centered rectangle
                drawCtx.fillStyle = this.color;
                drawCtx.globalAlpha = 0.6;
                drawCtx.fillRect(-this.length / 2, -this.width / 2, this.length, this.width);
                drawCtx.globalAlpha = 1;
 
                // Draw a pulsing core effect
                const coreRadius = this.width / 2;
                drawCtx.fillStyle = '#fff';
                drawCtx.beginPath();
                drawCtx.arc(0, 0, coreRadius * (1 + Math.sin(Date.now() / 100) * 0.2), 0, Math.PI * 2);
                drawCtx.fill();
 
                drawCtx.restore();
            },
 
            isColliding: function(px, py, pr) {
                // Check if the player is within the rotating beam area
                const dx = px - this.x;
                const dy = py - this.y;
 
                // Inverse rotation of player coordinates
                const cosA = Math.cos(-this.angle);
                const sinA = Math.sin(-this.angle);
 
                const rotatedY = dx * sinA + dy * cosA;
 
                // Check collision only against the width of the beam
                const halfWidth = this.width / 2;
 
                return rotatedY + pr > -halfWidth && rotatedY - pr < halfWidth;
            }
        });
    }
}
function spawn_D_attack() { // D: Drift Net (Slow, Wide Swarm - 1 Damage)
    const cw = canvas.width, ch = canvas.height;
    const count = 15; // High projectile count
    const speed = 0.8; // Slow speed
    for (let i = 0; i < count; i++) {
        // Spawn across the entire height of the screen, slightly off-screen left
        // Add a slight random offset to y for a less rigid pattern
        const yOffset = (Math.random() - 0.5) * 40;
        const x = -50;
        const y = (i / count) * ch + yOffset;
        game.attacks.push({
            ...createAttack(x, y, speed, 0, '#0099ff', 4, 1, 10000), // Damage set to 1
            update: function(dt) {
                // No change in trajectory, just lifetime
                this.lifetime -= dt;
            }
        });
    }
}
// --- NEW ATTACKS: E, F, and G ---
function spawn_E_attack() { // E: Echo Wave (Oscillating Corridors)
    const cw = canvas.width, ch = canvas.height;
    const waveWidth = 40; // Slightly narrower walls
    // 1. Create two oscillating barrier attacks (non-damaging walls)
    // Wall 1 (Left)
    game.attacks.push({
        x: cw / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw/4, amplitude: cw/8,
        update: function(dt) {
            // Horizontal sine wave oscillation
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        draw: function(drawCtx) {
            drawCtx.fillStyle = this.color;
            drawCtx.globalAlpha = 0.2; // Very transparent
            drawCtx.fillRect(this.x - this.width / 2, 0, this.width, this.height);
            // Draw visible lines
            drawCtx.strokeStyle = this.color;
            drawCtx.globalAlpha = 0.5;
            drawCtx.lineWidth = 1;
            drawCtx.strokeRect(this.x - this.width / 2, 0, this.width, this.height);
            drawCtx.globalAlpha = 1;
        },
        isColliding: function(px, py, pr) {
            // Check collision with player
            return px + pr > this.x - this.width / 2 &&
                   px - pr < this.x + this.width / 2;
        }
    });
    // Wall 2 (Right)
    game.attacks.push({
        x: cw * 3 / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw*3/4, amplitude: cw/8,
        update: function(dt) {
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        // Re-use draw and collision logic from Wall 1
        draw: game.attacks[game.attacks.length-2].draw,
        isColliding: game.attacks[game.attacks.length-2].isColliding
    });
    // 2. Create small, low-damage projectiles that move across the screen (The real threat)
    for (let i = 0; i < 6; i++) {
        const x = cw * (0.1 + i * 0.15);
        const y = ch / 2;
        const speed = 1.2 + Math.random();
        game.attacks.push({
            ...createAttack(x, y, 0, speed, '#fff', 5, 8, 8000), // Moderate damage
            update: function(dt) {
                // Reverse direction when hitting top/bottom
                if (this.y < 0 || this.y > ch) {
                    this.vy *= -1;
                }
                this.lifetime -= dt;
            }
        });
    }
}
function spawn_F_attack() { // F: Focal Point Grid (Converge and Burst)
    const cw = canvas.width, ch = canvas.height;
    // Random focus point, far enough from edges
    const focusX = cw * (0.3 + Math.random() * 0.4);
    const focusY = ch * (0.3 + Math.random() * 0.4);
    const speed = 1.5;
    for (let i = 0; i < 8; i++) {
        // Spawn from random edges
        let x, y;
        const edge = Math.floor(Math.random() * 4); // 0=Top, 1=Bottom, 2=Left, 3=Right
        if (edge === 0) { x = Math.random() * cw; y = 0; }
        else if (edge === 1) { x = Math.random() * cw; y = ch; }
        else if (edge === 2) { x = 0; y = Math.random() * ch; }
        else { x = cw; y = Math.random() * ch; }
 
        // Calculate initial velocity towards the focus point
        const dx = focusX - x;
        const dy = focusY - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
 
        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;
        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#00ffff', 6, 12, 12000), // Medium-high damage
            focusX: focusX,
            focusY: focusY,
            state: 'inbound', // 'inbound' or 'outbound'
            update: function(dt) {
                if (this.state === 'inbound') {
                    const distToFocus = Math.sqrt((this.x - this.focusX)**2 + (this.y - this.focusY)**2);
                    if (distToFocus < 20) { // Near focus point - trigger burst
                        this.state = 'outbound';
                        // Calculate new velocity (burst outwards from focus)
                        const angle = Math.atan2(this.y - this.focusY, this.x - this.focusX) + (Math.random() - 0.5) * 0.5;
                        this.vx = Math.cos(angle) * speed * 2; // Double speed on burst
                        this.vy = Math.sin(angle) * speed * 2;
                        // Draw a visual burst cue
                        startShake(100, 3);
                        showPopup('BURST!', this.focusX, this.focusY, 200, '#ff0000');
                    }
                }
                this.lifetime -= dt;
            }
        });
    }
}
function spawn_G_attack() { // FIXED: Nerfed G attack (reduced diggers/stagger for playability)
    // Spawn 2 diggers with longer stagger
    for (let i = 0; i < 2; i++) {
        setTimeout(() => {
            if (game.mode !== 'menu' && game.mode !== 'gameover') {
                spawnDigger();
            }
        }, i * 1200); // Stagger by 1200ms
    }
    // Visual cue
    showPopup('DIGGERS INCOMING!', canvas.width / 2, canvas.height - 50, 1500, '#8B4513');
}
function spawn_H_attack() { // H: Horizontal Barrage (Waves of horizontal lines)
    const cw = canvas.width, ch = canvas.height;
    const numWaves = 5;
    const speed = 1.8;
    for (let wave = 0; wave < numWaves; wave++) {
        setTimeout(() => {
            if (game.mode !== 'menu' && game.mode !== 'gameover') {
                for (let i = 0; i < 6; i++) {
                    const y = wave * (ch / (numWaves + 1));
                    game.attacks.push({
                        ...createAttack(-20, y, speed, 0, '#ff4444', 6, 6, 8000),
                        update: function(dt) {
                            this.x += this.vx * dt / 16;
                            this.lifetime -= dt;
                        }
                    });
                }
            }
        }, wave * 1000);
    }
}
function spawn_I_attack() { // I: Interlocking Rings (Expanding concentric circles)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    for (let i = 0; i < 5; i++) {
        const radius = 50 + i * 40;
        game.attacks.push({
            x: centerX, y: centerY, vx: 0, vy: 0,
            color: '#44ff44', radius: 3, damage: 7, lifetime: 10000, type: 'ring',
            ringRadius: radius,
            expansionSpeed: 0.8 + i * 0.2,
            update: function(dt) {
                this.ringRadius += this.expansionSpeed;
                this.lifetime -= dt;
            },
            draw: function(drawCtx) {
                drawCtx.strokeStyle = this.color;
                drawCtx.lineWidth = this.radius * 2;
                drawCtx.beginPath();
                drawCtx.arc(this.x, this.y, this.ringRadius, 0, Math.PI * 2);
                drawCtx.stroke();
            },
            isColliding: function(px, py, pr) {
                const dist = Math.sqrt((px - this.x)**2 + (py - this.y)**2);
                return Math.abs(dist - this.ringRadius) < pr + this.radius;
            }
        });
    }
}
function spawn_Z_attack() { // Z: Zonal Collapse (Zig-zag)
    const cw = canvas.width, ch = canvas.height;
    const count = 5;
    for (let i = 0; i < count; i++) {
        const x = cw / 2;
        const y = ch / 2;
        const angle = (Math.PI * 2 / count) * i;
        const vx = Math.cos(angle) * 3;
        const vy = Math.sin(angle) * 3;
        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#00ffcc', 6, 15, 6000),
            state: 0, // 0: out, 1: zig-zag in
            maxDist: 300,
            update: function(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                const distFromCenter = Math.sqrt((this.x - cw / 2)**2 + (this.y - ch / 2)**2);
                if (distFromCenter > this.maxDist && this.state === 0) {
                    this.state = 1;
                }
                if (this.state === 1) {
                    // Zig-zag back towards center
                    this.vx = (cw / 2 - this.x) * 0.002 * Math.sin(Date.now() / 200);
                    this.vy = (ch / 2 - this.y) * 0.002 * Math.cos(Date.now() / 200);
                }
                this.lifetime -= dt;
            }
        });
    }
}
// Unique Attack Functions - World 2 Examples
function spawn_Enter_attack() { // Enter: The Hard Commit (Vertical Beams)
    const cw = canvas.width, ch = canvas.height;
    // Create large, slow moving vertical beams
    for (let i = 0; i < 3; i++) {
        const x = cw / 4 + i * cw / 4;
        const width = 30;
        const speed = 0.5;
        game.attacks.push({
            x: x, y: -ch / 2, vx: 0, vy: speed,
            color: '#ff6600', radius: width / 2, damage: 30, lifetime: 10000, type: 'beam',
            width: width, height: ch * 2,
            update: function(dt) {
                this.y += this.vy * dt;
                this.vy += 0.001; // Gravity effect
                if (this.y > ch + ch / 2) this.lifetime = 0;
            },
            draw: function(drawCtx) {
                drawCtx.fillStyle = this.color;
                drawCtx.globalAlpha = 0.5;
                drawCtx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                drawCtx.globalAlpha = 1;
            },
            isColliding: function(px, py, pr) {
                // Check AABB collision
                return px + pr > this.x - this.width / 2 &&
                       px - pr < this.x + this.width / 2 &&
                       py + pr > this.y - this.height / 2 &&
                       py - pr < this.y + this.height / 2;
            }
        });
    }
}
function spawn_ArrowRight_attack() { // ArrowRight: Directional Current
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 10; i++) {
        const x = cw * 0.1;
        const y = Math.random() * ch;
        const speed = 1 + Math.random();
        game.attacks.push({
            ...createAttack(x, y, speed, 0, '#00bfff', 5, 5, 8000),
            baseVx: speed,
            update: function(dt) {
                // Persistent force field pushes right
                this.vx = this.baseVx + 0.1 * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                if (this.x > cw + 100) this.lifetime = 0;
                this.lifetime -= dt;
            }
        });
    }
}
const UNIQUE_ATTACK_REGISTRY = {
    // World 1 Unique Attacks
    'a': spawn_A_attack,
    'b': spawn_B_attack,
    'c': spawn_C_attack,
    'd': spawn_D_attack,
    'e': spawn_E_attack, // <-- NEW E
    'f': spawn_F_attack, // <-- NEW F
    'g': spawn_G_attack, // <-- FIXED: Nerfed G
    'h': spawn_H_attack, // <-- NEW H: To avoid fallback duplication
    'i': spawn_I_attack, // <-- NEW I: To avoid fallback duplication
    'z': spawn_Z_attack,
    // World 2 Unique Attacks
    'Enter': spawn_Enter_attack,
    'ArrowRight': spawn_ArrowRight_attack,
    // NOTE: All other keys (j-y, 0-9, symbols, unicode) now use an easier fallback (straight edge shots),
    // ensuring no homing duplication and balanced difficulty.
};
function spawnPatternForStage(stageKey) {
    const key = stageKey.toLowerCase();
    // Check if a unique attack is defined
    if (UNIQUE_ATTACK_REGISTRY[key]) {
        UNIQUE_ATTACK_REGISTRY[key]();
    } else {
        // Easier Fallback: Straight-line shots from all edges (no homing, lower damage)
        const cw = canvas.width, ch = canvas.height;
        const sides = 4;
        const numShotsPerSide = 4;
        const speed = 1.2;
        for (let side = 0; side < sides; side++) {
            for (let i = 0; i < numShotsPerSide; i++) {
                let x, y, vx, vy;
                const spacing = cw / (numShotsPerSide + 1);
                if (side === 0) { // Top
                    x = (i + 1) * spacing;
                    y = -20;
                    vx = 0;
                    vy = speed;
                } else if (side === 1) { // Bottom
                    x = (i + 1) * spacing;
                    y = ch + 20;
                    vx = 0;
                    vy = -speed;
                } else if (side === 2) { // Left
                    x = -20;
                    y = (i + 1) * spacing;
                    vx = speed;
                    vy = 0;
                } else { // Right
                    x = cw + 20;
                    y = (i + 1) * spacing;
                    vx = -speed;
                    vy = 0;
                }
                game.attacks.push({
                    ...createAttack(x, y, vx, vy, '#888888', 5, 4, 6000),
                    update: function(dt) {
                        this.lifetime -= dt;
                    }
                });
            }
        }
    }
}
// --- GAME FLOW AND STATE MANAGEMENT ---
function showMenu() {
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    // Reset state and hide HUD/Canvas elements
    game.mode = 'menu';
    // Hide all game-related UI
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    // Show menu UI
    menu.classList.remove('hidden');
    gameover.classList.add('hidden');
    shop.classList.add('hidden');
    updateHUD();
}
function startGame(world) {
    game.mode = 'playing';
    game.world = world;
    game.survivalTime = 0;
    player.hp = player.maxHp;
    player.shield = 0;
    player.dead = false;
    game.attacks = [];
    game.diggers = []; // Reset diggers
    game.lastTime = performance.now();
    // Reset player position to center of the canvas
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
    // Periodic Table skin logic on spawn
    if (player.equippedSkinId === 'periodic') {
        player.skinState.periodicElement = getRandomPeriodicElement();
    }
    // For cat, init next change if needed
    if (player.equippedSkinId === 'cat_txt' && !player.skinState.catNextChangeTime) {
        player.skinState.catNextChangeTime = Date.now() + (1000 + Math.random() * 1000);
    }
    // Hide menus and show game elements
    menu.classList.add('hidden');
    gameover.classList.add('hidden');
    shop.classList.add('hidden');
    hud.classList.remove('hidden');
    canvas.style.display = 'block';
    // Update HUD now that game state is set
    updateHUD();
    // Start the loop
    if (!game.animationFrameId) {
        game.animationFrameId = requestAnimationFrame(mainLoop);
    }
}
function gameOver() {
    // Calculate credits based on survival time
    const creditsGained = Math.floor(game.survivalTime * BONUS_CREDITS_PER_SEC);
    player.credits += creditsGained;
    showPopup(`+${creditsGained} Credits!`, canvas.width / 2, canvas.height / 2 + 50, 1500, '#ffeb3b');
    saveProgress();
    player.dead = true;
    game.mode = 'gameover';
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    // Hide HUD/Canvas and show gameover screen
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    gameover.classList.remove('hidden');
    menu.classList.add('hidden');
    shop.classList.add('hidden');
    document.getElementById('finalScore').textContent = `Survival Time: ${game.survivalTime.toFixed(1)}s`;
    startShake(1000, 10);
}
// --- MAIN LOOP ---
function mainLoop(time) {
    if (game.mode !== 'playing') {
        if (game.animationFrameId) {
             cancelAnimationFrame(game.animationFrameId);
             game.animationFrameId = null;
        }
        return;
    }
    const dt = time - game.lastTime;
    game.lastTime = time;
    const cw = canvas.width, ch = canvas.height;
    // Update survival time
    game.survivalTime += dt / 1000;
    // Player movement update (using simple mouse follow for now)
    player.x = Math.max(player.radius, Math.min(cw - player.radius, player.x + (mouse.x - player.x) * 0.1));
    player.y = Math.max(player.radius, Math.min(ch - player.radius, player.y + (mouse.y - player.y) * 0.1));
    // Attack Spawning - Random key from world
    if (Math.random() < 0.05) { // Spawn new pattern every 20 frames on average
        const keys = game.world === 'world1' ? WORLD1_KEYS : WORLD2_FULL;
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        spawnPatternForStage(randomKey);
        game.stageKey = randomKey;
    }
    // Update Attacks and Check Collisions
    game.attacks = game.attacks.filter(attack => {
        // Base movement
        if (attack.update) attack.update(dt);
        attack.x += attack.vx * dt / 16;
        attack.y += attack.vy * dt / 16;
        // Collision Check
        const attackRadius = attack.radius || 10;
 
        let collision = false;
        if (attack.isColliding) {
            collision = attack.isColliding(player.x, player.y, player.radius);
        } else {
            const dx = player.x - attack.x;
            const dy = player.y - attack.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            collision = dist < player.radius + attackRadius;
        }
        if (collision) {
            const damage = attack.damage || 5;
            let finalDamage = damage;
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, finalDamage);
                player.shield -= shieldAbsorbed;
                finalDamage -= shieldAbsorbed;
            }
            if (finalDamage > 0) {
                player.hp -= finalDamage;
                game.lastDamageTime = Date.now();
                startShake(150, 5);
                // Only show damage popup if damage was actually taken
                if (Math.round(finalDamage) > 0) {
                     showPopup(`-${Math.round(finalDamage)} HP`, player.x, player.y - 20, 500, '#f55');
                }
            }
            if (player.hp <= 0) {
                gameOver();
                return false; // Remove attack on hit
            }
            // Only remove projectile if it actually deals damage, otherwise let passive threats persist.
            if (attack.damage > 0) {
                return false; // Remove attack on hit
            }
        }
        // Lifetime and boundary check
        return attack.lifetime > 0 &&
               attack.x > -100 && attack.x < cw + 100 &&
               attack.y > -100 && attack.y < ch + 100;
    });
    // Update Diggers and Check Collisions
    game.diggers = game.diggers.filter(digger => {
        if (digger.update) digger.update(dt);
        digger.x += digger.vx * dt / 16;
        digger.y += digger.vy * dt / 16;
        // Collision Check
        const dx = player.x - digger.x;
        const dy = player.y - digger.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const collision = dist < player.radius + digger.size;
        if (collision) {
            let finalDamage = digger.damage;
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, finalDamage);
                player.shield -= shieldAbsorbed;
                finalDamage -= shieldAbsorbed;
            }
            if (finalDamage > 0) {
                player.hp -= finalDamage;
                game.lastDamageTime = Date.now();
                startShake(200, 6);
                showPopup(`-${finalDamage} HP`, player.x, player.y - 20, 500, '#8B4513');
            }
            if (player.hp <= 0) {
                gameOver();
                return false;
            }
            return false; // Remove digger on hit
        }
        // Lifetime and boundary check
        return digger.lifetime > 0 &&
               digger.y > -50;
    });
    // Draw Everything
    ctx.clearRect(0, 0, cw, ch);
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, cw, ch);
    // FIX: Use ctx.save() and ctx.restore() to contain the screen shake translation
    ctx.save();
    // Apply shake offset
    const shakeX = Math.random() * game.shake - game.shake / 2;
    const shakeY = Math.random() * game.shake - game.shake / 2;
    ctx.translate(shakeX, shakeY);
    // Draw Attacks
    game.attacks.forEach(attack => {
        if (attack.draw) {
            attack.draw(ctx);
        } else {
            ctx.fillStyle = attack.color || '#fff';
            ctx.beginPath();
            ctx.arc(attack.x, attack.y, attack.radius || 10, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    // Draw Diggers
    game.diggers.forEach(digger => {
        ctx.fillStyle = digger.color;
        ctx.fillRect(digger.x - digger.size / 2, digger.y - digger.size / 2, digger.size, digger.size);
        // Simple "digging" trail
        ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
        ctx.fillRect(digger.x - digger.size / 2, digger.y + digger.size / 2, digger.size, 8);
    });
    // Draw Player
    renderPlayerSkin(dt);
    // Draw Shield
    if (player.shield > 0) {
        const shieldRatio = player.shield / MAX_SHIELD;
        ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + shieldRatio * 0.5})`;
        ctx.lineWidth = 5 * shieldRatio;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    // Draw Health Bar
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : (hpRatio > 0.2 ? '#ff0' : '#f00');
    ctx.fillRect(player.x - 15, player.y + player.radius + 5, 30 * hpRatio, 3);
    ctx.restore(); // Restores context, automatically resetting the translate (shake)
    // Update HUD and Loop
    updateHUD();
    game.animationFrameId = requestAnimationFrame(mainLoop);
}
// --- MENU AND KEYPAD LOGIC ---
// --- SKINS SHOP LOGIC ---
function showSkinsShop() {
    menu.classList.add('hidden');
    shop.classList.remove('hidden');
    renderShopCatalog();
}
function renderShopCatalog() {
    const catalogContainer = document.getElementById('skinCatalog');
    catalogContainer.innerHTML = '';
    document.getElementById('shopCredits').textContent = player.credits;
    SKIN_CATALOG.forEach(skin => {
        const card = document.createElement('div');
        card.className = 'skin-card';
        card.innerHTML = `
            <h3>${skin.name}</h3>
            <div class="preview">
                <canvas id="preview-${skin.id}" width="40" height="40"></canvas>
            </div>
            <p>${skin.desc}</p>
            <div class="actions"></div>
        `;
        const actionsDiv = card.querySelector('.actions');
        const isOwned = progress.ownedSkins.includes(skin.id);
        const isEquipped = player.equippedSkinId === skin.id;
        if (isEquipped) {
            actionsDiv.innerHTML = `<button disabled>EQUIPPED</button>`;
        } else if (isOwned) {
            const equipBtn = document.createElement('button');
            equipBtn.textContent = 'EQUIP';
            equipBtn.onclick = () => equipSkin(skin.id);
            actionsDiv.appendChild(equipBtn);
        } else {
            const purchaseBtn = document.createElement('button');
            const canAfford = player.credits >= skin.price;
 
            purchaseBtn.textContent = `BUY - ${skin.price} CR`;
            purchaseBtn.disabled = !canAfford;
            purchaseBtn.classList.toggle('disabled', !canAfford);
 
            if (canAfford) {
                purchaseBtn.onclick = () => purchaseSkin(skin.id, skin.price);
            } else {
                purchaseBtn.title = 'Not enough credits!';
            }
            actionsDiv.appendChild(purchaseBtn);
        }
        // Add hover events for preview animation
        card.onmouseenter = () => animatePreview(skin.id, card);
        card.onmouseleave = () => drawStaticPreview(skin.id);
        // Initial static draw
        drawStaticPreview(skin.id);
        catalogContainer.appendChild(card);
    });
}
function equipSkin(skinId) {
    player.equippedSkinId = skinId;
    saveProgress();
    renderShopCatalog(); // Refresh shop view
    showPopup(`Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 1000, '#00ff44');
}
function purchaseSkin(skinId, price) {
    if (player.credits >= price) {
        player.credits -= price;
        progress.ownedSkins.push(skinId);
        player.equippedSkinId = skinId; // Auto-equip on purchase
 
        saveProgress();
        renderShopCatalog(); // Refresh shop view
        updateHUD();
 
        showPopup(`Purchased & Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 2000, '#ffeb3b');
    } else {
        showPopup(`Not enough credits!`, canvas.width/2, canvas.height/2, 1000, '#f55');
    }
}
// --- CHEAT CODE HANDLING ---
cheatInput.addEventListener('input', (e) => {
    const code = e.target.value.toLowerCase();
    if (code === 'nexus7') {
        SKIN_CATALOG.forEach(skin => {
            if (!progress.ownedSkins.includes(skin.id)) {
                progress.ownedSkins.push(skin.id);
            }
        });
        player.credits = 999999;
        progress.credits = player.credits;
        saveProgress();
        e.target.value = '';
    }
});
// --- EVENT LISTENERS AND INITIALIZATION ---
let mouse = { x: 0, y: 0 };
window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
window.ontouchmove = e => { if (e.touches.length > 0) { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; e.preventDefault(); }};
window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
};
// Menu Button Wiring
precodedBtn.onclick = () => {
    startGame('world1');
};
precodedUniBtn.onclick = () => {
    startGame('world2');
};
skinsShopBtn.onclick = showSkinsShop;
shopBackBtn.onclick = () => { shop.classList.add('hidden'); menu.classList.remove('hidden'); };
// Key R restart
document.addEventListener('keydown', e => {
    if (e.key === 'r' || e.key === 'R') {
        player.hp = player.maxHp;
        player.shield = 0;
        player.dead = false;
        game.attacks = [];
        game.diggers = [];
        showMenu(); // Use the dedicated function to clean up and transition
    }
});
// Initial Setup
window.onload = function () {
    window.onresize(); // Set initial canvas size
    loadProgress();
    showMenu(); // Ensure the menu is shown initially and the game loop is stopped
};
</script>
</body>
</html></DOCUMENT>
