<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lexi-Glitch Arena - V2 System</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Global Styling & Font (Inter) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
        :root {
            --primary-bg: #111827; /* Dark Slate */
            --secondary-bg: #1f2937; /* Lighter Slate */
            --accent-green: #10b981; /* Emerald Green */
            --accent-yellow: #f59e0b; /* Amber */
            --text-light: #f9fafb; /* White */
            --text-mute: #9ca3af; /* Gray */
            --border-color: #374151; /* Medium Gray */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
        }

        /* Console/Code-like Font for the Arena and Log */
        .mono-font {
            font-family: 'Space Mono', monospace;
        }

        /* UI Panel Styling */
        .ui-panel {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        /* Custom Scrollbar for Logs */
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: var(--secondary-bg);
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: var(--accent-green);
        }

        /* Button Hover Effects (Translated from old script requirement) */
        .btn-hover {
            transition: all 0.2s ease-in-out;
            transform: scale(1);
        }
        .btn-hover:hover {
            background-color: var(--accent-green);
            color: var(--primary-bg);
            box-shadow: 0 0 10px var(--accent-green);
            transform: scale(1.02);
        }
        .btn-hover:active {
            transform: scale(0.98);
        }

        /* Game Arena Canvas Styling */
        #gameCanvas {
            border: 2px solid var(--accent-green);
            background-color: #000000;
            cursor: crosshair;
        }

        /* Modal Backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
        }

        /* Skin Card Hover Effect */
        .skin-card:hover {
            border-color: var(--accent-green);
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.7);
            cursor: pointer;
            transform: translateY(-2px);
            transition: all 0.3s ease-in-out;
        }

        .skin-card-equipped {
            border-color: var(--accent-yellow) !important;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.8) !important;
        }
    </style>
</head>
<body class="flex flex-col h-screen p-4">

    <!-- Header Section -->
    <header class="mb-4 text-center">
        <h1 class="text-3xl font-bold mono-font text-accent-green">LEXI-GLITCH ARENA</h1>
        <p class="text-sm text-text-mute">Development Assisted by HARP & REX | V2 Core System</p>
    </header>

    <!-- Main Content Grid -->
    <main class="flex-grow grid grid-cols-12 gap-4">

        <!-- Left Panel: Game Status & Network -->
        <div class="col-span-12 lg:col-span-3 flex flex-col space-y-4">
            <!-- Game Status Panel -->
            <div class="ui-panel p-4 rounded-lg flex-shrink-0">
                <h2 class="text-xl font-bold mb-2 border-b border-border-color pb-1">STATUS</h2>
                <div class="mono-font text-sm space-y-1">
                    <p>Round Timer: <span id="roundTimer" class="text-accent-yellow">--</span>s</p>
                    <p>Player ID: <span id="localUserId" class="text-accent-green">...</span></p>
                    <p>Opponent ID: <span id="remoteUserId" class="text-accent-yellow">N/A</span></p>
                    <p>Connection: <span id="connectionStatus" class="text-text-mute">DISCONNECTED</span></p>
                    <p>Energy: <span id="playerEnergy" class="text-accent-green">100</span></p>
                </div>
            </div>

            <!-- Network/WebRTC Control Panel -->
            <div class="ui-panel p-4 rounded-lg flex-grow flex flex-col">
                <h2 class="text-xl font-bold mb-2 border-b border-border-color pb-1">NETWORK (WebRTC P2P)</h2>
                <div class="mono-font text-sm space-y-3 flex-grow">
                    <button id="btnCreateOffer" class="btn-hover w-full py-2 bg-indigo-600 rounded-lg text-text-light font-bold">1. Create Offer</button>
                    <button id="btnCreateAnswer" class="btn-hover w-full py-2 bg-teal-600 rounded-lg text-text-light font-bold" disabled>2. Create Answer</button>

                    <label for="signalBox" class="block text-text-mute mt-2">Signal Data (Copy/Paste):</label>
                    <textarea id="signalBox" rows="6" class="w-full bg-black border border-border-color p-2 text-accent-green text-xs rounded-lg custom-scroll" placeholder="Paste Offer/Answer here..."></textarea>
                    <button id="btnProcessSignal" class="btn-hover w-full py-2 bg-gray-600 rounded-lg text-text-light font-bold">3. Process Signal</button>

                    <p id="dataChannelStatus" class="text-center pt-2 text-accent-yellow">Data Channel: Closed</p>
                </div>
            </div>
        </div>

        <!-- Center Panel: Game Arena & Input -->
        <div class="col-span-12 lg:col-span-6 flex flex-col space-y-4">
            <!-- Game Arena Canvas -->
            <div class="flex-grow flex items-center justify-center bg-black rounded-lg">
                <canvas id="gameCanvas" width="800" height="600" class="w-full h-full max-h-[600px] rounded-lg"></canvas>
            </div>

            <!-- Player Input/Queue -->
            <div class="ui-panel p-3 rounded-lg flex-shrink-0">
                <label for="commandInput" class="text-sm text-text-mute block mb-1">Lexi-Command Input (Type to attack):</label>
                <input type="text" id="commandInput" class="w-full h-10 bg-black border border-accent-green p-2 text-xl mono-font rounded-lg focus:outline-none focus:ring-2 focus:ring-accent-green" maxlength="10" placeholder="Type letters/symbols...">
                <p class="text-xs text-text-mute pt-1">Queue: <span id="attackQueue" class="text-accent-yellow mono-font">_ _ _</span></p>
            </div>
        </div>

        <!-- Right Panel: Shop & Game Log -->
        <div class="col-span-12 lg:col-span-3 flex flex-col space-y-4">
            <!-- Shop/Skins Button -->
            <button id="btnOpenShop" class="btn-hover w-full py-3 bg-accent-yellow text-primary-bg font-extrabold text-lg rounded-lg shadow-lg flex-shrink-0">
                <span class="mr-2">SHOP</span> | CREDITS: <span id="playerCredits">0</span>
            </button>

            <!-- Game Log/Console Output -->
            <div class="ui-panel p-4 rounded-lg flex-grow flex flex-col overflow-hidden">
                <h2 class="text-xl font-bold mb-2 border-b border-border-color pb-1">GAME LOG</h2>
                <div id="gameLog" class="mono-font text-xs space-y-1 overflow-y-auto custom-scroll flex-grow">
                    <!-- Log messages will appear here -->
                </div>
            </div>
        </div>
    </main>

    <!-- Modal for Shop System -->
    <div id="shopModal" class="fixed inset-0 modal-backdrop hidden items-center justify-center p-4" onclick="handleModalClick(event)">
        <div class="ui-panel w-full max-w-4xl p-6 rounded-xl relative transform transition-all duration-300 scale-95 opacity-0" id="shopContent">
            <h2 class="text-3xl font-bold mono-font mb-4 text-accent-yellow border-b border-border-color pb-2">LEXI-SKIN STORE</h2>
            <p class="text-text-light mb-4">Current Credits: <span id="modalCredits" class="text-accent-green font-bold">0</span></p>

            <div id="skinsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 custom-scroll max-h-96 overflow-y-auto pr-2">
                <!-- Skin Cards will be injected here -->
            </div>

            <button onclick="closeShopModal()" class="btn-hover absolute top-3 right-3 text-2xl text-text-light hover:text-accent-yellow">
                &times;
            </button>
        </div>
    </div>

    <script type="module">
        // =================================================================
        // GLOBAL CONSTANTS AND SETUP
        // =================================================================
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        const INPUT_FIELD = document.getElementById('commandInput');
        const MAX_ENERGY = 100;
        const FPS = 60;
        const MS_PER_FRAME = 1000 / FPS;
        const LOCAL_USER_ID = crypto.randomUUID().substring(0, 8); // Unique ID for P2P signaling

        // Display User ID immediately
        document.getElementById('localUserId').textContent = LOCAL_USER_ID;

        // V1 (Legacy) and V2 (Complex/Realistic) Skins
        const SKINS = [
            // V1: Legacy Skins (Simple Visuals/Effects)
            { id: 'S101', name: 'Legacy Byte', cost: 0, equipped: true, version: 'V1', color: '#0f0', effectDesc: 'Standard projectile speed, basic energy regen.' },
            { id: 'S102', name: 'Glitch Stream', cost: 1500, equipped: false, version: 'V1', color: '#ff0', effectDesc: 'Slightly slower projectiles, high damage output.' },
            { id: 'S103', name: 'Zero-Day', cost: 3000, equipped: false, version: 'V1', color: '#f00', effectDesc: 'Low health, but passive ability grants temporary invulnerability on kill.' },

            // V2: Current (Realistic/Complex) Skins
            { id: 'S201', name: 'HARP Protocol', cost: 5000, equipped: false, version: 'V2', color: '#00f', effectDesc: 'Defense-focused. Typing symbols grants temporary Shield HP.' },
            { id: 'S202', name: 'REX Engine', cost: 7500, equipped: false, version: 'V2', color: '#f0f', effectDesc: 'Mobility-focused. Typing vowels increases movement speed for 3 seconds.' },
            { id: 'S203', name: 'Phantom Key', cost: 10000, equipped: false, version: 'V2', color: '#fff', effectDesc: 'Stealth-focused. After 5 seconds of inactivity, become briefly invisible to opponent.' }
        ];

        // Map of all characters to unique attack actions (The core unique mechanic)
        // This object defines the attack logic for every possible keystroke.
        const CHARACTER_ACTIONS = {
            // Letters (A-Z) - Primary Attack/Defense
            'a': { type: 'attack', power: 10, cost: 5, description: 'Alpha Strike: Standard projectile.' },
            'b': { type: 'utility', power: 5, cost: 8, description: 'Barrier Field: Small, temporary shield.' },
            'c': { type: 'attack', power: 12, cost: 6, description: 'C-Bomb: Medium damage, delayed explosion.' },
            'd': { type: 'movement', power: 1, cost: 4, description: 'Dash: Short forward dash.' },
            'e': { type: 'utility', power: 10, cost: 3, description: 'Energy Burst: Regenerate 10 Energy.' },
            'f': { type: 'attack', power: 15, cost: 10, description: 'Flame Array: High damage, linear projectile.' },
            'g': { type: 'utility', power: 0, cost: 5, description: 'Grapple: Pull opponent slightly closer.' },
            'h': { type: 'attack', power: 8, cost: 5, description: 'Homing Missile: Low power, guaranteed hit (slow).' },
            'i': { type: 'movement', power: 0, cost: 3, description: 'I-Frame: Brief moment of invulnerability.' },
            'j': { type: 'utility', power: 0, cost: 5, description: 'Jitter: Briefly scramble opponent movement.' },
            'k': { type: 'attack', power: 20, cost: 15, description: 'Kilo-Shot: Very high power, high cost.' },
            'l': { type: 'utility', power: 5, cost: 7, description: 'Lifesteal: Deal small damage, heal 5 HP.' },
            'm': { type: 'utility', power: 0, cost: 5, description: 'Mine Deploy: Deploy static proximity mine.' },
            'n': { type: 'utility', power: 0, cost: 3, description: 'Nullify: Destroy nearest incoming projectile.' },
            'o': { type: 'attack', power: 10, cost: 5, description: 'Orbital Strike: Area-of-effect marker.' },
            'p': { type: 'attack', power: 7, cost: 4, description: 'Penetrator: Ignores 5 points of shield.' },
            'q': { type: 'movement', power: 0, cost: 4, description: 'Quick-Shift: Teleport a short distance randomly.' },
            'r': { type: 'utility', power: 0, cost: 5, description: 'Rebound: Reflect next incoming projectile.' },
            's': { type: 'attack', power: 10, cost: 5, description: 'Shotgun Blast: Wide cone of low-power shots.' },
            't': { type: 'utility', power: 0, cost: 3, description: 'Tempo Boost: Increase typing speed briefly.' },
            'u': { type: 'utility', power: 0, cost: 5, description: 'Uplink: Increase Credits earned for 10s.' },
            'v': { type: 'attack', power: 10, cost: 5, description: 'Vector Trace: Damage over time effect.' },
            'w': { type: 'movement', power: 1, cost: 4, description: 'Warp: Controlled long-range movement.' },
            'x': { type: 'utility', power: 0, cost: 10, description: 'X-Factor: Randomly trigger two other actions.' },
            'y': { type: 'attack', power: 10, cost: 5, description: 'Y-Axis Beam: Vertical damage line.' },
            'z': { type: 'utility', power: 0, cost: 5, description: 'Zero Lag: Remove all debuffs.' },

            // Numbers (0-9) - Resources/Status Effects
            '0': { type: 'resource', power: 200, cost: 0, description: 'Code Zero: Gain 200 Credits.' },
            '1': { type: 'status', power: 5, cost: 5, description: 'Status-1: Slow opponent movement.' },
            '2': { type: 'status', power: 5, cost: 5, description: 'Status-2: Drain opponent energy.' },
            '3': { type: 'resource', power: 10, cost: 0, description: 'Code 3: Full Energy Refill.' },
            '4': { type: 'status', power: 5, cost: 5, description: 'Status-4: Opponent camera shake.' },
            '5': { type: 'status', power: 5, cost: 5, description: 'Status-5: Temporary reverse controls.' },
            '6': { type: 'resource', power: 500, cost: 0, description: 'Code Six: Gain 500 Credits.' },
            '7': { type: 'status', power: 5, cost: 5, description: 'Status-7: Opponent weapon jam (cannot attack).' },
            '8': { type: 'status', power: 5, cost: 5, description: 'Status-8: Opponent debuff stacking.' },
            '9': { type: 'resource', power: 10, cost: 0, description: 'Code Nine: Small Health Boost (10 HP).' },

            // Symbols/Punctuation - Utility/Complex Effects
            '.': { type: 'utility', power: 0, cost: 10, description: 'Finalize: Execute the entire command queue immediately.' },
            '!': { type: 'attack', power: 30, cost: 20, description: 'Exclamation: Devastating single hit (high cost).' },
            '#': { type: 'defense', power: 25, cost: 15, description: 'Hash Shield: Large temporary shield.' },
            '$': { type: 'resource', power: 0, cost: 0, description: 'Cash Out: Convert 5 Energy to 100 Credits.' },
            '%': { type: 'status', power: 50, cost: 10, description: 'Percent Debuff: Reduce opponent damage output by 50% for 5s.' },
            '^': { type: 'movement', power: 0, cost: 5, description: 'Uplift: Jump/boost movement.' },
            '&': { type: 'utility', power: 0, cost: 10, description: 'Duplicate: Duplicate the previous action in the queue.' },
            '*': { type: 'attack', power: 1, cost: 1, description: 'Star Scatter: Rapid fire low damage projectile.' },
            '(': { type: 'utility', power: 0, cost: 5, description: 'Open Block: Start a sequence of buffered commands.' },
            ')': { type: 'utility', power: 0, cost: 5, description: 'Close Block: Release the buffered command sequence.' },
            '@': { type: 'attack', power: 5, cost: 5, description: 'At-Tag: Marks opponent for increased damage from next attack.' },
            // Add more common symbols...
            '/': { type: 'utility', power: 0, cost: 3, description: 'Divider: Clears one active debuff.' },
            '?': { type: 'resource', power: 0, cost: 5, description: 'Question: Reveals opponent current Energy/HP briefly.' },
            ';': { type: 'utility', power: 0, cost: 5, description: 'Separator: Allows two actions to be executed simultaneously.' },
            ':': { type: 'utility', power: 0, cost: 5, description: 'Colon: Reduces cost of the next action by 50%.' },
            '{': { type: 'defense', power: 10, cost: 5, description: 'Brace: Damage reduction for 2s.' },
            '}': { type: 'defense', power: 10, cost: 5, description: 'Brace: Damage reduction for 2s.' },
            '[': { type: 'defense', power: 10, cost: 5, description: 'Brace: Damage reduction for 2s.' },
            ']': { type: 'defense', power: 10, cost: 5, description: 'Brace: Damage reduction for 2s.' },
            '|': { type: 'attack', power: 15, cost: 10, description: 'Vertical Split: Wide vertical projectile.' },
            '\\': { type: 'attack', power: 15, cost: 10, description: 'Backslash Split: Wide diagonal projectile.' },
            '<': { type: 'movement', power: 1, cost: 4, description: 'Retreat: Fast back movement.' },
            '>': { type: 'movement', power: 1, cost: 4, description: 'Advance: Fast forward movement.' },
            '=': { type: 'utility', power: 0, cost: 7, description: 'Equilibrium: Balance HP with opponent (if difference is > 20).' },
            '+': { type: 'resource', power: 15, cost: 0, description: 'Plus: Heal 15 HP.' },
            '-': { type: 'status', power: 0, cost: 5, description: 'Minus: Opponent loses 15 Energy.' },

            // Example Unicode (Requires copy/paste, less likely to be typed but supported)
            'Ω': { type: 'attack', power: 50, cost: 30, description: 'Omega Blast: Ultimate high-cost, area-denial attack.' },
            'π': { type: 'status', power: 0, cost: 15, description: 'Pi Lock: Freeze opponent in place for 3s.' },
            '√': { type: 'utility', power: 0, cost: 10, description: 'Root: Create a temporary slow zone.' },
        };

        // =================================================================
        // GAME STATE MANAGEMENT (New Architecture)
        // =================================================================

        class GameEntity {
            constructor(id, x, y, color, isLocal) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.targetX = x; // For smooth movement
                this.targetY = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = 15;
                this.health = 100;
                this.maxHealth = 100;
                this.energy = MAX_ENERGY;
                this.maxEnergy = MAX_ENERGY;
                this.color = color;
                this.isLocal = isLocal;
                this.speed = 3;
                this.cooldowns = {};
                this.effects = {}; // Status effects like 'slow', 'stun'
                this.skin = SKINS[0];
            }

            update(dt) {
                // Apply status effects
                for (const effect in this.effects) {
                    this.effects[effect] -= dt;
                    if (this.effects[effect] <= 0) {
                        delete this.effects[effect];
                    }
                }

                // Smooth movement towards target (interpolation)
                const lerpFactor = 0.15;
                this.x += (this.targetX - this.x) * lerpFactor;
                this.y += (this.targetY - this.y) * lerpFactor;

                // Simple collision detection (keep within bounds)
                this.x = Math.max(this.radius, Math.min(CANVAS.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(CANVAS.height - this.radius, this.y));

                // Energy regeneration
                if (this.energy < this.maxEnergy) {
                    this.energy += 0.5 * dt;
                }
            }

            draw() {
                // Player Circle
                CTX.fillStyle = this.color;
                CTX.beginPath();
                CTX.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                CTX.fill();

                // Player ID Label
                CTX.fillStyle = 'white';
                CTX.textAlign = 'center';
                CTX.font = '10px Space Mono';
                CTX.fillText(this.id, this.x, this.y + this.radius + 10);

                // Health Bar (Above)
                const barWidth = 40;
                const barHeight = 5;
                const healthRatio = this.health / this.maxHealth;
                CTX.fillStyle = 'gray';
                CTX.fillRect(this.x - barWidth / 2, this.y - this.radius - barHeight - 5, barWidth, barHeight);
                CTX.fillStyle = healthRatio > 0.3 ? 'lime' : 'red';
                CTX.fillRect(this.x - barWidth / 2, this.y - this.radius - barHeight - 5, barWidth * healthRatio, barHeight);

                // Draw skin marker (V1/V2 indicator)
                CTX.fillStyle = this.skin.version === 'V2' ? '#f59e0b' : '#10b981';
                CTX.beginPath();
                CTX.arc(this.x + this.radius - 2, this.y - this.radius + 2, 4, 0, Math.PI * 2);
                CTX.fill();

                // Draw status effects (if any)
                if (this.effects.slow) {
                    CTX.fillStyle = 'rgba(0, 0, 255, 0.5)';
                    CTX.beginPath();
                    CTX.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    CTX.fill();
                }
            }
        }

        class GameState {
            constructor() {
                this.localPlayer = new GameEntity(LOCAL_USER_ID, CANVAS.width / 4, CANVAS.height / 2, '#10b981', true);
                this.remotePlayer = null; // Will be initialized upon connection
                this.projectiles = [];
                this.effects = [];
                this.credits = 1000;
                this.lastUpdate = performance.now();
                this.roundDuration = 0; // Tracks the current round time
                this.maxRoundTime = 0; // Set randomly between 5s and 12s
                this.isRoundActive = false;
                this.playerSkins = JSON.parse(JSON.stringify(SKINS)); // Deep copy skins for modification
            }

            initRound() {
                this.maxRoundTime = Math.random() * (12 - 5) + 5; // 5s to 12s
                this.roundDuration = 0;
                this.isRoundActive = true;
                this.localPlayer.health = this.localPlayer.maxHealth;
                this.localPlayer.energy = this.localPlayer.maxEnergy;
                this.projectiles = [];
                UIManager.log('New Arena Round Started!', 'yellow');
            }

            updateSkins(newSkins) {
                 this.playerSkins = newSkins;
            }
        }

        let gameState = new GameState();

        // =================================================================
        // NETWORK MANAGER (WebRTC)
        // =================================================================

        class NetworkManager {
            constructor() {
                this.pc = null; // RTCPeerConnection
                this.dataChannel = null;
                this.isInitiator = false;
                this.remoteUserId = null;
            }

            // Initializes the peer connection object
            initPeerConnection(isInitiator) {
                this.isInitiator = isInitiator;
                this.pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                this.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        // In a manual signaling scenario, we log candidates but rely on the user
                        // copying the main Offer/Answer SDP, which contains gathered candidates.
                        // The previous call here caused the 'this.handleSignal is not a function' error.
                        UIManager.log(`ICE Candidate Found: ${event.candidate.type}`, 'gray');
                    }
                };

                this.pc.oniceconnectionstatechange = () => {
                    UIManager.updateConnectionStatus(this.pc.iceConnectionState);
                    UIManager.log(`ICE State: ${this.pc.iceConnectionState}`, 'gray');
                };

                this.pc.onconnectionstatechange = () => {
                    UIManager.updateConnectionStatus(this.pc.connectionState);
                    UIManager.log(`Connection State: ${this.pc.connectionState}`, 'gray');
                };
            }

            // Handles the Data Channel setup
            setupDataChannel() {
                this.dataChannel.onopen = () => {
                    UIManager.log('Data Channel OPEN. P2P Connection established.', 'green');
                    document.getElementById('dataChannelStatus').textContent = 'Data Channel: OPEN';

                    // Initialize remote player and start the round
                    gameState.remotePlayer = new GameEntity(this.remoteUserId, CANVAS.width * 3 / 4, CANVAS.height / 2, '#f00', false);
                    gameState.initRound();

                    // Send initial player state
                    this.sendPlayerState();
                };

                this.dataChannel.onmessage = (event) => {
                    this.receiveData(event.data);
                };

                this.dataChannel.onclose = () => {
                    UIManager.log('Data Channel CLOSED. Opponent disconnected.', 'red');
                    document.getElementById('dataChannelStatus').textContent = 'Data Channel: Closed';
                    gameState.remotePlayer = null;
                };

                this.dataChannel.onerror = (error) => {
                    UIManager.log(`Data Channel Error: ${error}`, 'red');
                };
            }

            // 1. Initiator creates the WebRTC Offer
            async createOffer() {
                this.initPeerConnection(true);

                // Create and set the data channel for the initiator
                this.dataChannel = this.pc.createDataChannel('gameData');
                this.setupDataChannel();
                
                try {
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    const signal = JSON.stringify({
                        sdp: this.pc.localDescription,
                        senderId: LOCAL_USER_ID
                    });
                    UIManager.handleSignalOutput(signal);
                    UIManager.log('Generated Offer SDP. Copy/Paste to opponent.', 'yellow');
                    document.getElementById('btnCreateAnswer').disabled = true; // Only initiator creates offer
                } catch (error) {
                    UIManager.log(`Error creating Offer: ${error.name}`, 'red');
                }
            }

            // 2. Receiver creates the WebRTC Answer
            async createAnswer(offerSignal) {
                try {
                    const offer = JSON.parse(offerSignal).sdp;
                    this.remoteUserId = JSON.parse(offerSignal).senderId;
                    document.getElementById('remoteUserId').textContent = this.remoteUserId;

                    this.initPeerConnection(false);

                    // Set remote data channel listener
                    this.pc.ondatachannel = (event) => {
                        this.dataChannel = event.channel;
                        this.setupDataChannel();
                    };

                    await this.pc.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await this.pc.createAnswer();
                    await this.pc.setLocalDescription(answer);

                    const signal = JSON.stringify({
                        sdp: this.pc.localDescription,
                        senderId: LOCAL_USER_ID
                    });

                    UIManager.handleSignalOutput(signal);
                    UIManager.log('Generated Answer SDP. Copy/Paste back to initiator.', 'yellow');
                } catch (error) {
                    UIManager.log(`Error creating Answer: ${error.name}`, 'red');
                }
            }

            // 3. Processes the received signal (Offer, Answer, or ICE candidate)
            async processSignal(signalText) {
                try {
                    const signal = JSON.parse(signalText);

                    // Check if the signal is intended for the local player
                    if (signal.senderId === LOCAL_USER_ID) return;

                    // Set remote ID if not set
                    if (!this.remoteUserId) {
                        this.remoteUserId = signal.senderId;
                        document.getElementById('remoteUserId').textContent = this.remoteUserId;
                    }

                    if (signal.sdp) {
                        // Received SDP (Offer or Answer)
                        if (signal.sdp.type === 'offer' && !this.isInitiator) {
                            // Automatically start creating answer if it's an offer and we are not the initiator
                            document.getElementById('btnCreateAnswer').disabled = false;
                            UIManager.log('Received Offer. Click "Create Answer" to respond.', 'teal');
                            document.getElementById('signalBox').value = signalText; // Store for easy processing
                        } else if (signal.sdp.type === 'answer' && this.isInitiator) {
                            // Initiator receives the answer
                            await this.pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
                            UIManager.log('Received Answer. Connection attempt in progress...', 'green');
                        }
                    } else if (signal.candidate) {
                        // Received ICE Candidate
                        try {
                            // We ignore the candidate if remote description hasn't been set yet
                            if (this.pc.remoteDescription) {
                                await this.pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
                                UIManager.log('Added ICE Candidate.', 'gray');
                            }
                        } catch (e) {
                            UIManager.log(`Error adding ICE candidate: ${e.name}`, 'red');
                        }
                    }
                    document.getElementById('signalBox').value = ''; // Clear box after processing
                } catch (error) {
                    UIManager.log(`Invalid signal data: ${error.message}`, 'red');
                }
            }

            // Sends local player state to opponent
            sendPlayerState() {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    const localState = {
                        x: gameState.localPlayer.x,
                        y: gameState.localPlayer.y,
                        health: gameState.localPlayer.health,
                        energy: gameState.localPlayer.energy,
                        skin: gameState.localPlayer.skin.id,
                        projectiles: gameState.projectiles.map(p => ({ x: p.x, y: p.y, r: p.radius, c: p.color }))
                    };
                    this.dataChannel.send(JSON.stringify({ type: 'state', data: localState }));
                }
            }

            // Receives data and updates remote player state
            receiveData(data) {
                try {
                    const message = JSON.parse(data);
                    if (message.type === 'state' && gameState.remotePlayer) {
                        const state = message.data;
                        gameState.remotePlayer.targetX = state.x;
                        gameState.remotePlayer.targetY = state.y;
                        gameState.remotePlayer.health = state.health;
                        gameState.remotePlayer.energy = state.energy;
                        // For simplicity, projectiles are rendered locally upon attack, but state must be synced
                        //gameState.remoteProjectiles = state.projectiles;
                    } else if (message.type === 'attack' && gameState.isRoundActive) {
                        // Handle attack received
                        gameState.localPlayer.health -= message.data.damage;
                        UIManager.log(`HIT! Took ${message.data.damage} damage.`, 'red');
                        if (gameState.localPlayer.health <= 0) {
                            UIManager.log('DEFEAT! Opponent wins the round.', 'red');
                            gameState.isRoundActive = false;
                        }
                    }
                } catch (e) {
                    // Ignore non-JSON or malformed messages
                }
            }
        }

        const networkManager = new NetworkManager();

        // =================================================================
        // UI MANAGER (All UI interactions and updates)
        // =================================================================

        const UIManager = {
            gameLogElement: document.getElementById('gameLog'),
            shopModal: document.getElementById('shopModal'),
            shopContent: document.getElementById('shopContent'),

            log(message, color = 'text-text-light') {
                const logEntry = document.createElement('p');
                logEntry.className = `mono-font ${color}`;
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] > ${message}`;
                this.gameLogElement.prepend(logEntry);
                // Keep log capped at 50 entries
                while (this.gameLogElement.children.length > 50) {
                    this.gameLogElement.removeChild(this.gameLogElement.lastChild);
                }
            },

            updateHUD() {
                document.getElementById('playerCredits').textContent = gameState.credits.toLocaleString();
                document.getElementById('modalCredits').textContent = gameState.credits.toLocaleString();
                document.getElementById('playerEnergy').textContent = gameState.localPlayer.energy.toFixed(0);

                if (gameState.isRoundActive) {
                     const remainingTime = gameState.maxRoundTime - gameState.roundDuration;
                    document.getElementById('roundTimer').textContent = remainingTime > 0 ? remainingTime.toFixed(1) : '0.0';
                } else {
                    document.getElementById('roundTimer').textContent = 'STOPPED';
                }

                // Update input field placeholder based on skin
                INPUT_FIELD.placeholder = `Current Skin: ${gameState.localPlayer.skin.name}`;
            },

            updateConnectionStatus(state) {
                let color = 'text-text-mute';
                if (state === 'connected' || state === 'open') color = 'text-accent-green';
                if (state === 'connecting' || state === 'checking') color = 'text-accent-yellow';
                if (state === 'failed' || state === 'disconnected' || state === 'closed') color = 'text-red-500';
                document.getElementById('connectionStatus').className = color;
                document.getElementById('connectionStatus').textContent = state.toUpperCase();
            },

            handleSignalOutput(signal) {
                const signalBox = document.getElementById('signalBox');
                signalBox.value = signal;
                signalBox.select();
                signalBox.focus();
                this.log('Signal data copied to box. Please share it manually.', 'blue');
            },

            openShopModal() {
                this.renderShopSkins();
                this.shopModal.classList.remove('hidden');
                this.shopModal.classList.add('flex');
                setTimeout(() => {
                    this.shopContent.classList.remove('scale-95', 'opacity-0');
                    this.shopContent.classList.add('scale-100', 'opacity-100');
                }, 10);
                this.log('Shop Accessed.', 'gray');
            },

            closeShopModal() {
                this.shopContent.classList.remove('scale-100', 'opacity-100');
                this.shopContent.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    this.shopModal.classList.remove('flex');
                    this.shopModal.classList.add('hidden');
                }, 300);
            },

            handleModalClick(event) {
                if (event.target === this.shopModal) {
                    this.closeShopModal();
                }
            },

            renderShopSkins() {
                const container = document.getElementById('skinsContainer');
                container.innerHTML = '';

                gameState.playerSkins.forEach(skin => {
                    const isEquipped = gameState.localPlayer.skin.id === skin.id;
                    const canAfford = gameState.credits >= skin.cost;
                    const isOwned = skin.equipped || skin.cost === 0;

                    const card = document.createElement('div');
                    card.className = `skin-card ui-panel p-4 rounded-xl ${isEquipped ? 'skin-card-equipped' : 'border-border-color'} transition-all duration-300 border-2`;
                    card.innerHTML = `
                        <div class="flex justify-between items-center border-b pb-2 mb-2 border-border-color">
                            <h3 class="text-xl font-bold ${skin.version === 'V2' ? 'text-blue-400' : 'text-green-400'}">${skin.name}</h3>
                            <span class="px-2 py-1 text-xs rounded-full font-bold mono-font" style="background-color:${skin.color}; color:var(--primary-bg)">${skin.version}</span>
                        </div>
                        <p class="text-sm text-text-mute mb-3">${skin.effectDesc}</p>
                        <div class="text-center">
                            ${isEquipped ?
                                `<button class="w-full py-2 bg-accent-yellow text-primary-bg font-bold rounded-lg cursor-default">EQUIPPED</button>` :
                                isOwned ?
                                    `<button id="btnEquip-${skin.id}" class="btn-hover w-full py-2 bg-green-600 text-text-light font-bold rounded-lg" data-skin-id="${skin.id}">EQUIP</button>` :
                                    `<button id="btnBuy-${skin.id}" class="btn-hover w-full py-2 ${canAfford ? 'bg-indigo-600' : 'bg-gray-700 cursor-not-allowed'}" ${canAfford ? '' : 'disabled'} data-skin-id="${skin.id}">BUY | ${skin.cost.toLocaleString()} CR</button>`
                            }
                        </div>
                    `;
                    container.appendChild(card);
                });

                // Attach event listeners for the newly created buttons
                container.querySelectorAll('[data-skin-id]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const skinId = e.currentTarget.dataset.skinId;
                        if (e.currentTarget.id.startsWith('btnBuy')) {
                            ShopManager.buySkin(skinId);
                        } else if (e.currentTarget.id.startsWith('btnEquip')) {
                            ShopManager.equipSkin(skinId);
                        }
                    });
                });
            }
        };

        // =================================================================
        // SHOP MANAGER (Handles all skin and credit logic)
        // =================================================================

        const ShopManager = {
            buySkin(skinId) {
                const skin = gameState.playerSkins.find(s => s.id === skinId);
                if (skin && !skin.owned && gameState.credits >= skin.cost) {
                    gameState.credits -= skin.cost;
                    skin.equipped = true;
                    UIManager.log(`Purchased and Equipped skin: ${skin.name}`, 'yellow');
                    this.equipSkin(skinId);
                } else if (skin && !skin.owned && gameState.credits < skin.cost) {
                    UIManager.log('INSUFFICIENT CREDITS to purchase this skin.', 'red');
                }
                UIManager.updateHUD();
                UIManager.renderShopSkins();
            },

            equipSkin(skinId) {
                const newSkin = gameState.playerSkins.find(s => s.id === skinId);
                if (newSkin) {
                    // Unequip old skin
                    gameState.playerSkins.forEach(s => s.equipped = false);

                    // Equip new skin
                    newSkin.equipped = true;
                    gameState.localPlayer.skin = newSkin;

                    UIManager.log(`Equipped skin: ${newSkin.name} (${newSkin.version})`, 'green');
                }
                UIManager.updateHUD();
                UIManager.renderShopSkins();
            }
        };

        // =================================================================
        // GAME LOGIC (Attack and core mechanics)
        // =================================================================

        const GameLogic = {
            attack(char, player) {
                const action = CHARACTER_ACTIONS[char];
                if (!action) return;

                if (player.energy < action.cost) {
                    UIManager.log(`Insufficient Energy for '${char}'. Cost: ${action.cost}.`, 'red');
                    return;
                }

                player.energy -= action.cost;
                UIManager.log(`Executing: ${action.description}`, 'accent-green');
                networkManager.sendPlayerState(); // Sync state after energy change

                switch (action.type) {
                    case 'attack':
                        // Create a projectile
                        this.createProjectile(player, action.power);
                        break;
                    case 'defense':
                        // Apply temporary shield/defense buff
                        player.effects.shield = (player.effects.shield || 0) + 2; // 2 seconds shield
                        break;
                    case 'utility':
                        // Handle utility logic (e.g., healing, energy burst)
                        if (char === 'e') player.energy = Math.min(MAX_ENERGY, player.energy + action.power);
                        if (char === 'z') player.effects = {}; // Clear debuffs
                        if (char === 'l') {
                             // Lifesteal implementation: deal damage and heal
                            networkManager.dataChannel.send(JSON.stringify({ type: 'attack', data: { damage: 5 } }));
                            player.health = Math.min(player.maxHealth, player.health + 5);
                        }
                        break;
                    case 'movement':
                        // Handle movement logic (e.g., dash, warp)
                        const dashDistance = action.power * 50;
                        player.targetX += dashDistance * (player.isLocal ? 1 : -1); // Dash forward
                        break;
                    case 'resource':
                        // Handle resource logic (credits, health)
                        if (char === '0' || char === '6') gameState.credits += action.power;
                        if (char === '9' || char === '+') player.health = Math.min(player.maxHealth, player.health + action.power);
                        break;
                    case 'status':
                        // Send status effect to opponent
                         networkManager.dataChannel.send(JSON.stringify({ type: 'status', data: { effect: char, duration: 5 } }));
                        break;
                }

                // V2 Skin Passive Check (REX Engine: Mobility)
                if (player.skin.id === 'S202' && 'aeiou'.includes(char)) {
                    player.effects.speedBoost = 3; // 3 seconds speed boost
                    player.speed = 6;
                } else if (player.skin.id === 'S202' && !player.effects.speedBoost) {
                    player.speed = 3;
                }
            },

            createProjectile(shooter, damage) {
                if (!gameState.remotePlayer) return;

                // Calculate direction towards opponent
                const dx = gameState.remotePlayer.x - shooter.x;
                const dy = gameState.remotePlayer.y - shooter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                gameState.projectiles.push({
                    x: shooter.x,
                    y: shooter.y,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    damage: damage,
                    radius: 5,
                    color: shooter.color,
                    ownerId: shooter.id,
                    isLocal: shooter.isLocal
                });
            },

            updateProjectiles(dt) {
                gameState.projectiles = gameState.projectiles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Check boundaries
                    if (p.x < 0 || p.x > CANVAS.width || p.y < 0 || p.y > CANVAS.height) {
                        return false; // Remove if out of bounds
                    }

                    // Only local player's projectiles can hit the remote player
                    if (p.isLocal && gameState.remotePlayer) {
                        const target = gameState.remotePlayer;
                        const dist = Math.sqrt((p.x - target.x) ** 2 + (p.y - target.y) ** 2);
                        if (dist < target.radius + p.radius) {
                            // Hit detected: send attack message via DataChannel
                            networkManager.dataChannel.send(JSON.stringify({ type: 'attack', data: { damage: p.damage } }));
                            UIManager.log(`Dealt ${p.damage} damage to opponent.`, 'green');
                            return false; // Projectile destroyed
                        }
                    }
                    return true;
                });
            },
        };

        // =================================================================
        // INPUT HANDLER (Handles all key/mouse events)
        // =================================================================

        function handleKeyPress(event) {
            // Only allow typing if a round is active
            if (!gameState.isRoundActive) {
                UIManager.log('Round is inactive. Cannot execute commands.', 'red');
                return;
            }

            const char = event.key.toLowerCase();
            const action = CHARACTER_ACTIONS[char];

            if (action) {
                GameLogic.attack(char, gameState.localPlayer);
            }

            // Update the attack queue display
            const input = INPUT_FIELD.value;
            document.getElementById('attackQueue').textContent = input.toUpperCase().split('').join(' ');
        }

        function handleCanvasClick(event) {
            if (!gameState.isRoundActive) return;

            // Simple movement based on click location
            const rect = CANVAS.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            gameState.localPlayer.targetX = mouseX;
            gameState.localPlayer.targetY = mouseY;
        }

        // =================================================================
        // GAME LOOP (The heart of the new system)
        // =================================================================

        function gameLoop(timestamp) {
            const dt = (timestamp - gameState.lastUpdate) / MS_PER_FRAME; // Time delta for framerate independence
            gameState.lastUpdate = timestamp;

            // 1. Update Game State
            if (gameState.isRoundActive) {
                // Round Timer Update (5s - 12s)
                gameState.roundDuration += dt * (MS_PER_FRAME / 1000); // Add real time

                if (gameState.roundDuration >= gameState.maxRoundTime) {
                    UIManager.log('Round Timer Expired. Credits awarded.', 'yellow');
                    gameState.credits += 500; // Award credits for surviving the round
                    gameState.isRoundActive = false;
                }

                gameState.localPlayer.update(dt);
                if (gameState.remotePlayer) gameState.remotePlayer.update(dt);

                GameLogic.updateProjectiles(dt);

                // Send state update to opponent (throttled to network speed, e.g., every 50ms)
                if (timestamp % 50 < 10) {
                    networkManager.sendPlayerState();
                }

                // Check for win condition
                if (gameState.remotePlayer && gameState.remotePlayer.health <= 0) {
                     UIManager.log('VICTORY! Opponent defeated.', 'green');
                     gameState.credits += 2000;
                     gameState.isRoundActive = false;
                }
            }

            // 2. Render Graphics
            render();

            // 3. Update UI
            UIManager.updateHUD();

            // 4. Request next frame
            requestAnimationFrame(gameLoop);
        }

        function render() {
            // Clear canvas
            CTX.fillStyle = '#000';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Draw game boundaries/grid
            CTX.strokeStyle = '#374151';
            CTX.lineWidth = 1;
            CTX.strokeRect(0, 0, CANVAS.width, CANVAS.height);

            // Draw projectiles
            gameState.projectiles.forEach(p => {
                CTX.fillStyle = p.color;
                CTX.beginPath();
                CTX.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                CTX.fill();
            });

            // Draw players (Local must be drawn last to ensure visibility)
            if (gameState.remotePlayer) gameState.remotePlayer.draw();
            gameState.localPlayer.draw();

            // Draw round active overlay
            if (!gameState.isRoundActive) {
                 CTX.fillStyle = 'rgba(17, 24, 39, 0.9)'; // Dark overlay
                 CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
                 CTX.fillStyle = '#f59e0b';
                 CTX.textAlign = 'center';
                 CTX.font = '36px Space Mono';
                 CTX.fillText('ARENA STANDBY (NO CONNECTION / ROUND ENDED)', CANVAS.width / 2, CANVAS.height / 2);
                 CTX.font = '18px Inter';
                 CTX.fillText('Initiate P2P Connection or wait for new round start.', CANVAS.width / 2, CANVAS.height / 2 + 40);
            }
        }


        // =================================================================
        // INITIALIZATION AND EVENT LISTENERS
        // =================================================================

        window.onload = function() {
            // Set canvas size to fill container
            const canvasContainer = CANVAS.parentElement;
            CANVAS.width = canvasContainer.clientWidth;
            CANVAS.height = 600; // Fixed height, fill width

            // Center initial player position based on new width
            gameState.localPlayer.x = CANVAS.width / 4;
            gameState.localPlayer.y = CANVAS.height / 2;

            // Attach all UI button event listeners (fixing the previous issue)
            document.getElementById('btnOpenShop').addEventListener('click', UIManager.openShopModal);
            document.getElementById('gameCanvas').addEventListener('click', handleCanvasClick);
            document.getElementById('commandInput').addEventListener('input', handleKeyPress);

            // WebRTC Button Listeners
            document.getElementById('btnCreateOffer').addEventListener('click', () => networkManager.createOffer());
            document.getElementById('btnCreateAnswer').addEventListener('click', () => networkManager.createAnswer(document.getElementById('signalBox').value));
            document.getElementById('btnProcessSignal').addEventListener('click', () => networkManager.processSignal(document.getElementById('signalBox').value));

            UIManager.log('Lexi-Glitch Arena Initialized. Ready for P2P connection.', 'green');
            UIManager.log('Click on the black arena to move your avatar.', 'gray');
            UIManager.log('V1 Skins: Original / V2 Skins: Realistic, Complex Abilities.', 'yellow');

            // Start the game loop
            requestAnimationFrame(gameLoop);
        };

        // Handle window resize (responsive canvas)
        window.addEventListener('resize', () => {
            const canvasContainer = CANVAS.parentElement;
            CANVAS.width = canvasContainer.clientWidth;
            // Re-render immediately
            render();
        });
    </script>
</body>
</html>
